<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lobster|Fugaz+One|Google+Sans:400,500,700" />
  <link rel="stylesheet" href="index.css" />
  <style id="extraStyles"></style>
</head>
<body>

<script type="module">
import api from '../../src/scene/api.js';
import {_msg} from '../../src/magic.js';
import {rectify, href} from '../../src/scene/route.js';
import {Render, renderText, scaleCopy} from './render.js';
import scenes from '../../src/strings/scenes.js';

rectify(document.body);

const canvasOptions = new Map();

titleSurface.title = _msg`santatracker`;
canvasOptions.set(titleSurface, {
  color: 'white',
  width: 300,
  font: '40px "Lobster"',
  lineHeight: 60,
});

noticeSurface.title = _msg`error-unsupported`;
canvasOptions.set(noticeSurface, {
  color: '#99ccff',
  width: 300,
  font: '16px "Fugaz One"',
  lineHeight: 24,
});

const r = new Render();


function measureFont(fontFamily) {
  const div = document.createElement('div');
  div.style.fontFamily = fontFamily;
  div.style.fontSize = '100px';
  div.textContent = 'Some test string';
  document.body.appendChild(div);
  try {
    return div.offsetHeight;
  } finally {
    document.body.removeChild(div);
  }
}



function delayForFont(fontFamily, timeout = 8 * 1000) {
  const baseline = measureFont('monospace');

  let interval;
  const p = new Promise((resolve) => {
    interval = window.setInterval(() => {
      if (measureFont(fontFamily + ',monospace') !== baseline) {
        resolve();
      }
    }, 125);
    window.setTimeout(resolve, timeout);
  });

  return p.then(() => {
    window.clearInterval(interval);
  });
}

api.preload.wait(r.ready());

api.preload.wait(delayForFont('Fugaz One'));
api.preload.wait(delayForFont('Lobster'));


const houses = 'boatload codeboogie codelab penguindash presentbounce presentdrop snowball traditions translations wrapbattle'.split(/\s+/g);
(function() {
  let i = 0;
  houses.sort((a, b) => a.length - b.length + ++i);
}());
const houseAssetsPromise = api.preload.images(...houses.map((x) => `img/houses/${x}.gif`));


const otherAssetsPromise = api.preload.images('img/background.png', 'img/cave.png');


function targetSize() {
  const max = 2;
  const ratio = Math.min(max, Math.floor(window.innerWidth / 320)) || 1;

  return {
    width: 320,
    height: 320,
    ratio,
  };
}


api.ready(async () => {
  const fps = 10;
  let last = 0;
  let previousRatio = -1;

  // map of raw canvas to render target
  const scalableAssets = new Map();

  const houseAssets = await Promise.all(houseAssetsPromise);
  houseAssets.map((img, i) => {
    const house = houses[i];
    const node = document.createElement('a');
    const target = document.createElement('canvas');
    node.href = href(`${house}.html`);
    node.appendChild(target);
    games.appendChild(node);

    node.title = scenes[house];

    scalableAssets.set(img, target);
  });

  const [backgroundAsset, caveAsset] = await Promise.all(otherAssetsPromise);

  (function render(now=0) {
    window.requestAnimationFrame(render);

    const t = targetSize();

    if (previousRatio !== t.ratio) {
      games.style.fontSize = `${32 * t.ratio}px`;

      const backgroundAssetScaled = scaleCopy(backgroundAsset, null, t.ratio * 4);
      const caveAssetScaled = scaleCopy(caveAsset, null, t.ratio * 4);
      extraStyles.textContent = `
body {
  background-image: url(${backgroundAssetScaled.toDataURL()});
  background-size: ${60 * t.ratio}px;
}
#games a {
  background-image: url(${caveAssetScaled.toDataURL()});
  background-size: ${32 * t.ratio}px;
}
      `;

      canvasOptions.forEach((options, target) => {
        const canvas = renderText(target.title, options);
        scaleCopy(canvas, target, t.ratio);
      });

      // Render misc scalable assets, like the houses and text.
      scalableAssets.forEach((target, canvas) => {
        scaleCopy(canvas, target, t.ratio);
      });
    }

    if (now - last > (1000 / fps) || previousRatio !== t.ratio) {
      const {canvas} = r.render(null, t.width, t.height);
      scaleCopy(canvas, retroSurface, t.ratio);
      last = now;
    }

    previousRatio = t.ratio;
  }());

});

</script>

<canvas id="titleSurface"></canvas>
<div id="holder">
  <canvas id="retroSurface"></canvas>
  <div id="games"></div>
</div>
<canvas id="noticeSurface"></canvas>

</body>
</html>
