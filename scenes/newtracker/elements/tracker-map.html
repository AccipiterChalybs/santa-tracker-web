<!--
Copyright 2016 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../../../components/polymer/polymer.html">
<link rel="import" href="../../../components/iron-media-query/iron-media-query.html">
<link rel="import" href="../../../elements/santa-maps-api.html">
<link rel="import" href="tracker-map_module.html">

<script src="../../shared/js/mapstyles.js"></script>

<!--
Tracker map.
-->
<dom-module id="tracker-map">
<template>
  <style include="tracker-map_module"></style>

  <santa-maps-api on-api-load="_mapsAPIReady"></santa-maps-api>

  <iron-media-query query="(pointer: fine)" query-matches="{{_hasPointer}}"></iron-media-query>

  <div hidden>
    <!-- preloading -->
    <img src$="[[importPath]]/img/marker.png" id="marker" />
    <img src$="[[importPath]]/img/northpole.png" id="northpoleMarker" />
  </div>

  <div id="santa" tabindex="0" hidden>
    <div id="presents" hidden></div>
    <div class="sleigh" data-dir="se">
      <div class="back"></div>
      <div class="santa"></div>
      <div class="front"></div>
    </div>
  </div>

  <div id="legalnotices" style$="[[_computeLegalNoticesStyle(minimalUi)]]"></div>
  <div id="map"></div>

</template>
<script>
(function() {
  const POLYLINE_COLOR = '#22a528';
  const POLYLINE_WEIGHT = 2;
  const DIR_NAMES = 'n ne e se s sw w nw'.split(' ');
  const FOCUS_TIMEOUT = 30 * 1000;  // after this much inactivity, refocus

  function dirForHeading(heading) {
    if (isNaN(heading)) {
      return '';
    }
    const offset = 360 / (DIR_NAMES.length * 2);  // 27.5 deg
    const normalized = (((heading + offset) % 360) + 360) % 360;
    const index = Math.floor(normalized / 360 * DIR_NAMES.length);
    return DIR_NAMES[index];
  }

  function createSantaLayer(santaDiv, marker, northpoleMarker) {
    function SantaLayer(options, clickHandler, routeClickHandler) {
      // TODO(samthor): Use real template.
      this._container = santaDiv.cloneNode(true);
      this._container.addEventListener('click', function(event) {
        event.stopPropagation();  // prevents marker clicks when Santa was intended
        clickHandler();
      });
      this.setValues(options);

      this._sleigh = this._container.querySelector('.sleigh');
      this._presents = this._container.querySelector('#presents');

      this._routeClickHandler = routeClickHandler;
      this._markerPool = [];
      this._markers = [];
      this._lines = [];
      this._trailEndLatLng = null;

      this._activeTrail = new google.maps.Polyline({
        geodesic: true,
        strokeColor: POLYLINE_COLOR,
        strokeWeight: POLYLINE_WEIGHT,
      });
      this._activeTrail.bindTo('map', this);

      this._locationIcon = /** @type {google.maps.Icon} */({
        url: marker.src,
        size: new google.maps.Size(15, 18),
        scaledSize: new google.maps.Size(15, 18),
      });

      this._northpoleIcon = /** @type {google.maps.Icon} */({
        url: northpoleMarker.src,
        size: new google.maps.Size(132, 100),
        scaledSize: new google.maps.Size(132, 100),
        anchor: new google.maps.Point(66, 50),
      });

    }
    SantaLayer.prototype = new google.maps.OverlayView;

    /**
     * Maps API OverlayView lifecycle method, called when content panes are ready.
     */
    SantaLayer.prototype.onAdd = function() {
      const panes = this.getPanes();
      panes.floatPane.appendChild(this._container);
    };

    /**
     * Maps API OverlayView lifecycle method, called when content must be torn down.
     */
    SantaLayer.prototype.onRemove = function() {
      // NOTE: never called since SantaLayer's map is never nulled.
      this._container.parentNode.removeChild(this._container);
    };

    /**
     * Set the position and force a redraw.
     * @param {!google.maps.LatLng} latLng
     * @param {number} heading in range [0,360)
     */
    SantaLayer.prototype.setPosition = function(latLng, heading) {
      this.set('position', latLng);

      const presents = (heading == null);  // null or undefined are fine
      this._sleigh.hidden = presents;

      this._presents.hidden = !presents;

      if (presents) {
        const v = Math.round(Math.random());  // 0 or 1
        this._presents.className = `mode${v}`;
      } else if (!presents) {
        const dir = dirForHeading(heading);
        dir && this._sleigh.setAttribute('data-dir', dir);
        this._sleigh.hidden = !dir;
      }

      this.draw();
      this._updateActiveTrail();
    };

    /**
     * Sets the current trail of LatLng points. Draws opaque => transparent lines along the length.
     */
    SantaLayer.prototype.setLatLngTrail = function(trail) {
      if (trail.length !== this._lines.length + 1) {
        const map = this.getMap();
        this._lines.forEach((line) => line.setMap(null));
        this._lines = [];
        for (let i = 1; i < trail.length; ++i) {
          const frac = (1 / trail.length) * i;
          const line = new google.maps.Polyline({
            geodesic: true,
            strokeColor: POLYLINE_COLOR,
            strokeWeight: POLYLINE_WEIGHT,
            strokeOpacity: 1 - (frac * frac),
            map: map,
          });
          this._lines.push(line);
        }
      }

      this._lines.forEach(function(line, i) {
        line.setPath(trail.slice(i, i + 2));
      });
      this._trailEndLatLng = trail[0] || null;
      this._updateActiveTrail();
    };

    /**
     * Builds or reuses a marker for the tracker.
     */
    SantaLayer.prototype._fetchMarker = function(data) {
      let next = this._markerPool.pop();
      if (next) {
        next.setPosition(data.location);
        next.setMap(this.getMap());
      } else {
        next = new google.maps.Marker({
          position: data.location,
          map: this.getMap(),
        });
        next.addListener('click', this._onRouteMarkerClick.bind(this, next));
      }

      next.setIcon(data.isNorthPole() ? this._northpoleIcon : this._locationIcon);
      next.set('st_dest', data);
      return next;
    };

    /**
     * Releases a marker to the pool of unused markers.
     */
    SantaLayer.prototype._releaseMarker = function(marker) {
      if (marker) {
        marker.setMap(null);
        marker.set('st_dest', null);
        this._markerPool.push(marker);
      }
    };

    SantaLayer.prototype._onRouteMarkerClick = function(marker) {
      const dest = marker.get('st_dest');
      dest && this._routeClickHandler(dest);
    };

    /**
     * Specifiy the list of previous destinations, and an optional tail limit to show.
     */
    SantaLayer.prototype.setPreviousDestinations = function(destinations, limit) {
      // Clear head markers if the route gets smaller (offset change).
      while (this._markers.length > destinations.length) {
        this._releaseMarker(this._markers.pop());
      }

      // Add new markers when the route gets larger (normal operation).
      const map = this.getMap();
      while (destinations.length > this._markers.length) {
        // If there's a limit, don't actually make markers after the limit.
        if (limit > 0 && this._markers.length < destinations.length - limit) {
          this._markers.push(null);
          continue;
        }
        const dest = destinations[this._markers.length];
        this._markers.push(this._fetchMarker(dest));
      }

      // If a limit was specified, then hide previous markers.
      if (limit > 0) {
        for (let i = this._markers.length - limit; i >= 0; --i) {
          const hide = this._markers[i];
          if (!hide) {
            break;  // already hidden all these markers
          }
          this._markers[i] = null;
          this._releaseMarker(hide);
        }
      }
    };

    /**
     * Updates the active trail (the segment from trail => Santa), based on the latLngTrail and
     * Santa's location.
     */
    SantaLayer.prototype._updateActiveTrail = function() {
      const latLng = /** @type {google.maps.LatLng} */ (this.get('position'));

      if (latLng && this._trailEndLatLng) {
        this._activeTrail.setPath([latLng, this._trailEndLatLng]);
      } else {
        this._activeTrail.setPath([]);
      }
    };

    /**
     * Maps API OverlayView lifecycle method, called when content must be repositioned.
     */
    SantaLayer.prototype.draw = function() {
      const projection = this.getProjection();
      const latLng = /** @type {google.maps.LatLng} */ (this.get('position'));

      if (!latLng || !projection) {
        this._container.hidden = true;
      } else {
        this._container.hidden = false;

        const pos = projection.fromLatLngToDivPixel(latLng);
        this._container.style.transform = 'translate(' + pos.x + 'px, ' + pos.y + 'px)';
      }
    };
    return SantaLayer;
  }

  Polymer({
    is: 'tracker-map',

    properties: {
      _map: Object,
      _santaLayer: Object,
      _duringMapChange: {
        type: Boolean,
        value: true,
      },
      _duringResize: {
        type: Boolean,
        value: false,
      },

      /**
       * Whether the browser has a pointer. Used to control visibility of zoom controls, and bound
       * from `iron-media-query`.
       */
      _hasPointer: {
        type: Boolean,
        value: false,
      },

      /**
       * Whether the user has set a zoom, and it shouldn't be modified.
       */
      _userZoom: {
        type: Boolean,
        value: false,
        observer: '_userZoomChanged',
      },

      /**
       * Whether the camera should focus on Santa. Sets to false if the user pans around.
       */
      focusOnSanta: {
        type: Boolean,
        value: true,
        notify: true,
        observer: '_delaySantaFocus',
      },

      /**
       * The current google.maps.LatLng of Santa's location.
       */
      santaLatLng: {
        type: Object,
        value: null,
      },

      /**
       * Santa's heading, in degrees. If `null`, then Santa is at a city. If this is NaN, don't
       * show Santa at all.
       */
      santaHeading: {
        type: Number,
        value: NaN,
      },

      /**
       * Santa's trail, all previously shown stops. The first stop is always index zero.
       */
      trail: {
        type: Array,
        value: () => [],
      },

      /**
       * The length of a trail to display.
       */
      trailLength: {
        type: Number,
        value: 20,
      },

      /**
       * Whether to display in minimal UI mode.
       */
      minimalUi: {
        type: Boolean,
        value: false,
      },
    },

    observers: [
      '_updateMapState(_map, focusOnSanta, santaLatLng, santaHeading)',
      '_updateTrail(_map, trail, trailLength)',
      '_controlZoomButtons(_map, _hasPointer, minimalUi)',
    ],

    _calculateMapOffset: function() {
      const out = {x: 0, y: 0};
      if (!this.minimalUi) {
        // TODO(samthor): This could happen outside `tracker-map`, as this element shouldn't care
        // about cards laid on top of here.
        if (window.innerHeight < 450) {
          out.x = -window.innerWidth / 4;
          out.y = -30;
        } else {
          out.y = -60;  // roughly 1/2 the size of cards
        }
      }
      return out;
    },

    _updateMapState: function() {
      // nb. we need a delay here, to let window resizes etc settle
      this.debounce('_updateMapState', function() {
        if (!this._map || !this.santaLatLng) {
          return;
        }

        const santaLatLng = new google.maps.LatLng(this.santaLatLng);
        this._santaLayer.setPosition(santaLatLng, this.santaHeading);

        if (!this.focusOnSanta) {
          return;  // nothing else to do
        }

        let offsetSantaLatLng;
        const offset = this._calculateMapOffset();
        const projection = this._map.getProjection();
        if ((offset.x || offset.y) && projection) {
          // TODO(samthor): This code doesn't always run while Santa is delivering presents.
          const point = projection.fromLatLngToPoint(santaLatLng);
          const pow = Math.pow(2, this._map.getZoom());
          point.x -= offset.x / pow;
          point.y -= offset.y / pow;
          offsetSantaLatLng = projection.fromPointToLatLng(point);
        } else {
          offsetSantaLatLng = santaLatLng;
        }

        try {
          this._duringMapChange = true;
          this._map.setCenter(offsetSantaLatLng);

          if (!this._userZoom) {
            // If focused, the zoom is roughly inverse with screen size. Smaller devices see more
            // of the Earth, because they have less context around Santa.
            let zoom = Math.round(window.innerWidth / 240);
            zoom = Math.max(2, Math.min(6, zoom));
            this._map.setZoom(zoom);
          }
        } finally {
          this._duringMapChange = false;
        }
      }, 10);
    },

    _updateTrail: function() {
      if (!this._map) {
        return;
      }
      this._santaLayer.setPreviousDestinations(this.trail, this.minimalUi ? this.trailLength : -1);

      // Grab last `trailLength` entries, push Santa's location, reverse for the display.
      const slice = this.trail.slice(-this.trailLength).map((data) => data.location);
      slice.reverse();

      this._santaLayer.setLatLngTrail(slice);
    },

    _onWindowResize: function() {
      this._duringResize = true;
      window.requestAnimationFrame(() => {
        // at this point, the resize has settled: run _updateMapState again.
        this._duringResize = false;
        this._updateMapState();
      });

      google.maps.event.trigger(this._map, 'resize');
    },

    attached: function() {
      this._onWindowResize = this._onWindowResize.bind(this);
      window.addEventListener('resize', this._onWindowResize);

      const urls = [
        'img/chimney1.gif',
        'img/chimney2.gif',
        'img/marker.png',
        'img/northpole.png',
        'img/sleigh/effects.svg',
      ];

      'n ne e se s sw w nw'.split(' ').forEach((dir) => {
        urls.push(`img/sleigh/sleigh-${dir}-back.svg`);
        urls.push(`img/sleigh/sleigh-${dir}-front.svg`);
        urls.push(`img/sleigh/sleigh-${dir}-santa.svg`);
      });

      this.fire('preload', urls);
    },

    detached: function() {
      window.removeEventListener('resize', this._onWindowResize);
    },

    _onFollowSantaClick: function() {
      window.ga('send', 'event', 'tracker', 'santa', 'click');
      this._userZoom = false;
      this.focusOnSanta = true;
    },

    _onRouteMarkerClick: function(dest) {
      window.ga('send', 'event', 'tracker', 'marker', 'click');
      // TODO(samthor): do something.
      console.info('dest clicked', dest.id);
    },

    _userZoomChanged: function() {
      if (!this._userZoom) {
        // If userZoom was reset, we need to reposition the camera.
        this._updateMapState();
      }
    },

    _controlZoomButtons: function(map, hasPointer, minimalUi) {
      if (map) {
        // If the browser has a pointer (i.e., a mouse on desktop), show zoom controls.
        map.setOptions({zoomControl: hasPointer && !minimalUi});
      }
    },

    _delaySantaFocus: function() {
      if (!this.focusOnSanta) {
        this.debounce('_focusOnSantaChanged', function() {
          this.focusOnSanta = true;
        }, FOCUS_TIMEOUT);
      } else {
        this.cancelDebouncer('_focusOnSantaChanged');
      }
    },

    _mapsAPIReady: function() {
      if (this._map) {
        console.warn('shouldn\'t mapsAPIReady more than once');
        return;
      }

      const map = new google.maps.Map(this.$.map, {
        center: {lat: 0, lng: 0},
        zoom: 1,
        minZoom: 2,
        maxZoom: 6,  // ROK has own tiles at 7+
        // 'noPerTile': true,  // ???
        disableDefaultUI: true,
        zoomControl: this._hasPointer && !this.minimalUi,
        zoomControlOptions: {
          position: google.maps.ControlPosition.RIGHT_CENTER,
        },
        backgroundColor: '#68d5d0',
        styles: mapstyles.styles,
        scrollwheel: false,
        hideLegalNotices: true,  // rendered by mapdataproviders_changed
      });

      map.addListener('center_changed', () => {
        // If it's not a map change or resize, reset focusOnSanta.
        if (!this._duringMapChange && !this._duringResize) {
          this.focusOnSanta = false;
          this._delaySantaFocus();
          window.ga('send', 'event', 'tracker', 'map', 'move');
        }
      });

      map.addListener('zoom_changed', () => {
        // If it's not a map change, this is a user changing the zoom level.
        if (!this._duringMapChange) {
          this._userZoom = true;
          this._updateMapState();  // need to reposition Santa, due to offsets
          window.ga('send', 'event', 'tracker', 'map', 'zoom');
        }
      });

      map.addListener('mapdataproviders_changed', () => {
        const providers = /** @type {string} */ (map.get('mapDataProviders'));
        this.$.legalnotices.textContent = providers || '';
      });

      const SantaLayer = createSantaLayer(this.$.santa, this.$.marker, this.$.northpoleMarker);
      this._santaLayer = new SantaLayer(
          {map: map}, this._onFollowSantaClick.bind(this), this._onRouteMarkerClick.bind(this));
      this._map = map;
    },

    _computeLegalNoticesStyle: function(minimalUi) {
      if (minimalUi) {
        return null;
      }
      return 'top: 44px;';
    },

  });

}());
</script>
</dom-module>
  