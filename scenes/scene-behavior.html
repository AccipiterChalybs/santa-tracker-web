<!--
Copyright 2015 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../components/polymer/polymer.html" />
<link rel="import" href="../elements/santa-app-behavior.html" />
<link rel="import" href="../elements/santa-tutorial/santa-tutorial.html">

<script>
(function() {

  /**
   * Max number of milliseconds to wait before timing out and abandoning preload.
   */
  const maxPreloadTime = 10 * 1000;

  /**
   * Number of frames to spread image preload over.
   */
  const framesToSpread = 10;

  /** @polymerBehavior */
  window.SantaSceneBehaviorImpl = {
    hostAttributes: {tabindex: 0},

    properties: {

      /**
       * URL route for this scene.
       */
      route: {
        type: String,
        value: null,
      },

      /**
       * Assets loaded so far (out of `totalAssets`).
       */
      _assetsLoaded: {
        type: Number,
        value: 0,
      },

      /**
       * Total number of assets that will need to be preloaded. Assets must be
       * preloaded in onPreload or this will be ignored.
       */
      _totalAssets: {
        type: Number,
        value: 0,
      },

      /**
       * Contains the Promise which will resolve when this scene loads its resources. This will
       * always eventually resolve (possibly via timeout).
       */
      preload: {
        type: Object,
        readOnly: true,
      },

      /**
       * Contains the Set of pending Preload promises.
       */
      _pendingPreload: {
        type: Object,
        value: null,
      },

      /**
       * Contains the chain of promises calling onShow and onHide for this scene.
       */
      _showPromise: {
        type: Object,
        value: Promise.resolve(null),
      },

      /**
       * Stores our parent node for an extra frame, so events can be targeted correctly.
       */
      _lazyParent: {
        type: Object,
      },

    },

    listeners: {
      'preload': 'preloadEvent',
      'sound-ambient': 'onSoundAmbient',
    },

    observers: [
      '_progress(_assetsLoaded, _totalAssets, _pendingPreload)',
    ],

    ready: function() {
      this._setPreload(new Promise((resolve) => {
        this.addEventListener('_preload', resolve);
      }));

      // Run onPreload to preload resources. Resolves when assets are ready, when the timeout
      // expires, or immediatelyâ€”if there's nothing to preload.
      this._pendingPreload = new Set();
      this.onPreload && this.onPreload();
      const done = () => this.fire('_preload', null, {bubbles: false});
      if (!this._pendingPreload.size) {
        done();
      } else {
        this.async(done, maxPreloadTime);
      }

      this.preload.then(() => {
        this._pendingPreload = null;
      });
    },

    attached: function() {
      const show = this.preload.then(() => {
        // nb. put onShow into a rAF as this ensures the onHide method from any previous scene
        // is run before us. The same guarantees don't apply to attached: or detached:, as we
        // attach scenes to preload them.
        return new Promise((resolve) => requestAnimationFrame(resolve));
      }).then(() => {
        if (this._showPromise !== p || !this.isAttached) {
          return true;
        }
        this.onShow && this.onShow();
      });
      const p = this._showPromise = this._showPromise.then(() => show);

      this._lazyParent = this.parentNode;
    },

    detached: function() {
      this._showPromise = this._showPromise.then((skipped) => {
        if (!skipped) {
          this.onHide && this.onHide()
        }
        this._lazyParent = null;
      });
    },

    /**
     * Catch `sound-ambient` events, so that even if the scene has been removed, they are passed
     * up to our parent (presumed to be a `santa-app`). Uses the `_lazyParent` property, which
     * sticks around for a microtask after detached:.
     */
    onSoundAmbient: function(ev) {
      if (this.parentNode) {
        // do nothing, event is bubbled
      } else if (this._lazyParent) {
        // pass to our just-removed parent
        const opts = {bubbles: true, composed: true, detail: ev.detail};
        const ce = new CustomEvent('sound-ambient', opts);
        this._lazyParent.dispatchEvent(ce);
      } else {
        console.warn('got sound-ambient without parent', ev.localName, 'sound', ev.detail);
      }
    },

    /**
     * Adds a preload Promise to this scene.
     * @param {!Promise<*>} p
     */
    preloadPromise: function(p) {
      const preload = this._pendingPreload;
      if (!preload) {
        return;  // nothing to do, not really preloading
      }
      preload.add(p);

      ++this._totalAssets;
      p.catch((error) => {
        console.warn('preload', this.localName, 'error', error);
      }).then(() => {
        ++this._assetsLoaded;
        preload.delete(p);
        if (!preload.size) {
          this.fire('_preload', null, {bubbles: false});  // nb. resolves Promise in ready:
        }
      });
    },

    /**
     * A helper method that makes AJAX requests to load resources.
     */
    preloadPaths: function(urls) {
      if (!urls.length) {
        return;
      }

      const promises = urls.map((url) => {
        return new Promise((resolve) => {
          const x = new XMLHttpRequest();
          x.open('GET', this.resolveUrl(url));
          x.onload = resolve;
          x.onerror = resolve;
          x.send(null);
        });
      });

      this.preloadPromise(Promise.all(promises));
    },

    /**
     * A helper method for preloading an array of image URLs.
     * @param {!Array<string>} imageUrls
     */
    preloadImages: function(imageUrls) {
      if (!imageUrls.length) {
        return;  // do nothing
      }

      const p = new Promise((resolve) => {
        this._totalAssets += imageUrls.length;
        let done = 0;

        const onload = () => {
          ++this._assetsLoaded;
          ++done;
          if (done === imageUrls.length) {
            resolve();
          }
        };

        const imagesPerRaf = Math.max(1, Math.ceil(imageUrls.length / framesToSpread));
        let imageIndex = 0;

        (function rafCallback() {
          for (let i = 0; i < imagesPerRaf && imageIndex < imageUrls.length; ++i) {
            const img = new Image();
            img.onerror = img.onload = onload;
            img.src = this.resolveUrl(imageUrls[imageIndex++]);
          }

          if (imageIndex < imageUrls.length) {
            this.async(rafCallback);
          }
        }).call(this);
      });

      this.preloadPromise(p);
    },

    /**
     * Preload a set of sounds for this scene via Klang.
     * @param {string} soundSetName
     */
    preloadSounds: function(soundSetName) {
      this.fire('sound-preload', soundSetName);
    },

    /**
     * Preload the request from a contained element.
     */
    preloadEvent: function(ev) {
      const source = Polymer.dom(ev).path[0];
      const detail = ev.detail;

      if (detail instanceof Array) {
        const urls = ev.detail.map((url) => source.resolveUrl(url));
        this.preloadImages(urls);
      } else if (detail instanceof Promise) {
        this.preloadPromise(detail);
      } else {
        console.debug('unknown preload from', source.localName, 'detail', detail);
      }
    },

    _progress: function(assetsLoaded, totalAssets, pendingPreload) {
      if (totalAssets && pendingPreload) {
        this.fire('scene-progress', assetsLoaded / totalAssets);
      }
    },

  };

  /** @polymerBehavior */
  window.SantaSceneBehavior = [window.SantaAppBehavior, SantaSceneBehaviorImpl];

  /** @polymerBehavior */
  window.SantaSceneGameButtonsBehavior = {
    properties: {
      game: {
        type: Object,
      },

      pause: {
        type: Boolean,
        observer: '_pauseChanged',
      },

      _firstPlay: {
        type: Boolean,
        value: true,
      }
    },

    /** Plays or restarts this game. */
    start: function() {
      if (!this.game) {
        return false;
      }

      if (this._firstPlay) {
        this.game.start();
        this._firstPlay = false;
      } else {
        this.game.restart();
      }

      return true;
    },

    _pauseChanged: function() {
      if (!this.game || this._firstPlay) {
        return;
      }

      if (this.pause) {
        this.game.pause();
      } else {
        this.game.resume();
      }
    },

  };

})();
</script>
