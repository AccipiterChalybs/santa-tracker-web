<!--
Copyright 2015 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../components/polymer/polymer.html" />
<link rel="import" href="../elements/santa-app-behavior.html" />

<script>
(function() {

  /**
   * Max number of milliseconds to wait before timing out and abandoning preload.
   */
  const maxPreloadTime = 30 * 1000;

  /**
   * Number of frames to spread image preload over.
   */
  const framesToSpread = 10;

  /** @polymerBehavior */
  window.SantaSceneBehaviorImpl = {
    hostAttributes: {tabindex: 0},

    properties: {

      /**
       * URL route for this scene.
       */
      route: {
        type: String,
        value: null,
      },

      /**
       * If `true`, the scene is active. In Santa Tracker, this is set by `lazy-pages.
       *
       * Note that this intentionally starts undefined so that its observer is only called after
       * the object is ready.
       */
      active: {
        type: Boolean,
        reflectToAttribute: true,
        observer: '_activeChanged',
      },

      /**
       * If `true`, the scene was previously loaded. This includes if a preload
       * took too long.
       */
      loaded: {
        type: Boolean,
        notify: true,
        value: false,
      },

      /**
       * Assets loaded so far (out of `totalAssets`).
       */
      _assetsLoaded: {
        type: Number,
        value: 0,
      },

      /**
       * Total number of assets that will need to be preloaded. Assets must be
       * preloaded in onPreload or this will be ignored.
       */
      _totalAssets: {
        type: Number,
        value: 0,
      },

      /**
       * Contains the Promise which will resolve when this scene loads its resources. This will
       * always eventually resolve (possibly via timeout).
       */
      preload: {
        type: Object,
        readOnly: true,
      },

      /**
       * Contains the Set of pending Preload promises.
       */
      _pendingPreload: {
        type: Object,
      },

    },

    observers: [
      '_progress(_assetsLoaded, _totalAssets)',
    ],

    ready: function() {
      if (this.loaded) {
        // we are a clone: pretend to already be loaded
        this._setPreload(Promise.resolve());
        return;
      }

      // Setup preload Promise. This resolves when all assets are ready, or when the timeout
      // expires. It should never reject.

      const preload = new Set();
      this._pendingPreload = preload;

      const p = new Promise(function(resolve) {
        this.onPreload && this.onPreload();

        if (!preload.size) {
          return resolve();
        }
        this.async(resolve, maxPreloadTime);  // resolve on timeout anyway
        this.addEventListener('preload', resolve);
      }.bind(this));

      p.then(function() {
        if (this._pendingPreload === preload) {
          this._pendingPreload = null;
        }
        this.loaded = true;
      }.bind(this));

      this._setPreload(p);
    },

    _activeChanged: function() {
      if (this.active) {
        this.onShow && this.onShow();
      } else {
        this.onHide && this.onHide();
      }
    },

    /**
     * Adds a preload Promise to this scene.
     * @param {!Promise<*>} p
     */
    preloadPromise: function(p) {
      const preload = this._pendingPreload;
      if (!preload) {
        return;  // nothing to do, not really preloading
      }
      preload.add(p);

      const done = function() {
        ++this._assetsLoaded;

        preload.delete(p);
        if (!preload.size) {
          this.fire('preload', preload, {bubbles: false});  // nb. resolves Promise in ready:
        }
      }.bind(this);

      ++this._totalAssets;
      p.then(done, done).catch(function(error) {
        console.warn('preload for scene', this.route, 'error', error);
      });
    },

    /**
     * A helper method for preloading an array of image URLs.
     * @param {!Array<string>} imageUrls
     */
    preloadImages: function(imageUrls) {
      if (!imageUrls.length) {
        return;  // do nothing
      }

      const p = new Promise(function(resolve) {
        this._totalAssets += imageUrls.length;
        let done = 0;

        const onload = function() {
          ++this._assetsLoaded;
          ++done;
          if (done === imageUrls.length) {
            resolve();
          }
        }.bind(this);

        const imagesPerRaf = Math.max(1, Math.ceil(imageUrls.length / framesToSpread));
        let imageIndex = 0;
        (function rafCallback() {
          for (let i = 0; i < imagesPerRaf && imageIndex < imageUrls.length; ++i) {
            const img = new Image();
            img.onerror = img.onload = onload;
            img.src = this.resolveUrl(imageUrls[imageIndex++]);
          }

          if (imageIndex < imageUrls.length) {
            this.async(rafCallback);
          }
        })();
      }.bind(this));

      this.preloadPromise(p);
    },

    /**
     * Preload a set of sounds for this scene via Klang.
     * @param {string} soundSetName
     */
    preloadSounds: function(soundSetName) {
      this.fire('sound-preload', soundSetName);
    },

    _progress: function(assetsLoaded, totalAssets) {
      if (totalAssets) {
        this.fire('scene-progress', assetsLoaded / totalAssets);
      }
    },

    /**
     * Helper method. Just does equality.
     */
    _equals: function(a, b) {
      return a == b;
    },

    /**
     * Helper method. Computes the ternary operation on arg.
     */
    _computeTernary: function(arg, pve, nve) {
      return arg ? pve : nve;
    },

  };

  /** @polymerBehavior */
  window.SantaSceneBehavior = [window.SantaAppBehavior, SantaSceneBehaviorImpl];

  /** @polymerBehavior */
  window.SantaSceneGameButtonsBehavior = {
    properties: {
      game: {
        type: Object,
      },

      pause: {
        type: Boolean,
        observer: '_pauseChanged',
      },

      _firstPlay: {
        type: Boolean,
        value: true,
      }
    },

    /** Plays or restarts this game. */
    start: function() {
      if (!this.game) {
        return;
      }

      if (this._firstPlay) {
        this.game.start();
        this._firstPlay = false;
      } else {
        this.game.restart();
      }

      this.pause && this.game.pause();  // paused before start
    },

    _pauseChanged: function() {
      if (!this.game || this._firstPlay) {
        return;
      }

      if (this.pause) {
        this.game.pause();
      } else {
        this.game.resume();
      }
    },

  };

})();
</script>
