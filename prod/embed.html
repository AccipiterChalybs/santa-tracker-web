<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <style type="text/css">
html {
  background: #3ec4f0;
}
body {
  margin: 0;
}
iframe.game {
  min-height: 100vh;
  width: 100vw;
  border: 0;
  display: block;
}
  </style>
</head>
<body>
  <script>

const staticPath = document.body.getAttribute('data-static') || '';
const m = staticPath.match(/^(.*)(\/[^\/]*)$/);
if (!m) {
  throw new Error(`couldn't match static path: ${staticPath}`);
}
const staticBase = m[1];
const staticOrigin = (new URL(staticBase)).origin;


async function waitForEvent(target, eventName) {
  return new Promise((r) => target.addEventListener(eventName, r, {once: true}));
}


async function configureKlangFrame() {
  const iframe = document.createElement('iframe');
  iframe.hidden = true;
  iframe.setAttribute('allow', 'speaker');
  iframe.src = `${staticBase}/controllers/klang.html`;
  document.body.appendChild(iframe);
  await waitForEvent(iframe, 'load');
  return iframe;
}


async function configureFrame() {
  const sceneName = window.location.hash.substr(1) || window.location.search.substr(1);
  if (!sceneName) {
    throw new Error('no scene provided');
  }

  const iframe = document.createElement('iframe');
  iframe.className = 'game';
  iframe.setAttribute('allow', 'accelerometer; autoplay; camera; fullscreen; encrypted-media; gyroscope; picture-in-picture; speaker; unsized-media');
  iframe.setAttribute('allowfullscreen', '');
  console.info('setting inner frame src', iframe.src);
  iframe.src = `${staticBase}/scenes/${sceneName}/${document.documentElement.lang || 'index'}.html`;
  document.body.appendChild(iframe);
  await waitForEvent(iframe, 'load');
  return iframe;
}


async function run() {
  // create Klang frame and send mute, but don't await until all other work is done
  const klangFramePromise = configureKlangFrame();
  const klangPostPromise = klangFramePromise.then((klangFrame) => {
    return (...args) => klangFrame.contentWindow.postMessage(args, staticOrigin);
  });
  const timeoutMutePromise = klangPostPromise.then((klangPost) => {
    // If we later decide that scenes should start loud, this can be removed: the timeout mostly
    // just ensures the initial beat of whatever scene music doesn't play (otw it would fade out).
    klangPost('fire', 'global_sound_off');
    return new Promise((r) => window.setTimeout(r, 500));
  });

  const embedPort = await matchWindowMessage((ev) => {
    // nb. data should be 'santaandroid'
    if (ev.source === null && ev.ports && ev.ports[0]) {
      return ev.ports[0];
    }
  });

  const iframe = await configureFrame();
  const gamePort = await matchWindowMessage((ev) => {
    if (ev.source === iframe.contentWindow && ev.data === 'game') {
      return ev.ports[0];
    }
  });

  const klangPost = await klangPostPromise;
  await timeoutMutePromise;

  const embedmessage = (ev) => {
    console.debug('got data from embed', ev.data);
    switch (ev.data) {
      case 'unmute':
        klangPost('fire', 'global_sound_on');
        break;
      case 'mute':
        klangPost('fire', 'global_sound_off');
        break;
      default:
        gamePort.postMessage(ev.data);
    }
  };
  embedPort.onmessage = embedmessage;

  gamePort.onmessage = (ev) => {
    const {type, payload} = ev.data;

    if (type === 'klang') {
      klangPost(...payload);
    } else {
      const message = {type: `on${type}`, data: payload};
      embedPort.postMessage(JSON.stringify(message));
    }
  };
}


/**
 * @param {function(!Event): ?MessagePort} check to run
 * @return {!Promise<!MessagePort>}
 */
function matchWindowMessage(check) {
  return new Promise((resolve) => {
    const handler = (ev) => {
      const out = check(ev);
      if (out != null) {
        resolve(out);
        window.removeEventListener('message', handler);
      }
    };
    window.addEventListener('message', handler);
  });
}


run().catch((err) => {
  throw err;
});

  </script>
</body>
</html>