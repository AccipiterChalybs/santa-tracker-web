<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <style type="text/css">
html {
  background: #3ec4f0;
}
body {
  margin: 0;
}
iframe.game {
  min-height: 100vh;
  width: 100vw;
  border: 0;
  display: block;
}
  </style>
</head>
<body>
  <script>

const staticPath = document.body.getAttribute('data-static') || '';
const m = staticPath.match(/^(.*)(\/[^\/]*)$/);
if (!m) {
  throw new Error(`couldn't match static path: ${staticPath}`);
}
const staticBase = m[1];
const staticOrigin = (new URL(staticBase)).origin;


async function waitForEvent(target, eventName) {
  return new Promise((r) => target.addEventListener(eventName, r, {once: true}));
}


async function configureFrame() {
  const sceneName = window.location.hash.substr(1) || window.location.search.substr(1);
  if (!sceneName) {
    throw new Error('no scene provided');
  }

  const iframe = document.createElement('iframe');
  iframe.className = 'game';
  iframe.setAttribute('allow', 'accelerometer; autoplay; camera; fullscreen; encrypted-media; gyroscope; picture-in-picture; speaker; unsized-media');
  iframe.setAttribute('allowfullscreen', '');
  iframe.src = `${staticBase}/scenes/${sceneName}/${document.documentElement.lang || 'index'}.html?_embed=1`;
  console.info('setting inner frame src', iframe.src);
  document.body.appendChild(iframe);
  return iframe;
}


async function run() {
  const embedPort = await matchWindowMessage((ev) => {
    // nb. data should be 'santaandroid'
    if (ev.source === null && ev.ports && ev.ports[0]) {
      return ev.ports[0];
    }
  });

  const iframe = await configureFrame();
  const gamePortPromise = matchWindowMessage((ev) => {
    if (ev.source === iframe.contentWindow && ev.data === 'init') {
      return ev.ports[0];
    }
  });

  await waitForEvent(iframe, 'load');
  const gamePort = await gamePortPromise;

  const embedmessage = (ev) => {
    switch (ev.data) {
      case 'unmute':
        gamePort.postMessage({type: 'embed:unmute'});
        break;
      case 'mute':
        gamePort.postMessage({type: 'embed:mute'});
        break;
      default:
        if (ev.data.endsWith('Game')) {
          const type = ev.data.substr(ev.data.length - 4);
          gamePort.postMessage({type: ev.data, payload: null});
        } else {
          console.debug('unhandled from embed', ev.data);
        }
    }
  };
  embedPort.onmessage = embedmessage;

  gamePort.onmessage = (ev) => {
    if (typeof ev.data === 'number' || ev.data === null) {
      return;  // preload
    }

    const {type, payload} = ev.data;
    if (type === 'klang') {
      return;  // ignore, can't play sounds here
    }
    const message = {type: `on${type}`, data: payload};
    embedPort.postMessage(JSON.stringify(message));
  };
}


/**
 * @param {function(!Event): ?MessagePort} check to run
 * @return {!Promise<!MessagePort>}
 */
function matchWindowMessage(check) {
  return new Promise((resolve) => {
    const handler = (ev) => {
      const out = check(ev);
      if (out != null) {
        resolve(out);
        window.removeEventListener('message', handler);
      }
    };
    window.addEventListener('message', handler);
  });
}


run().catch((err) => {
  throw err;
});

  </script>
</body>
</html>