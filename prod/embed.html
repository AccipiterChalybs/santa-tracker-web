<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <style type="text/css">
html {
  background: #3ec4f0;
}
body {
  margin: 0;
}
iframe {
  min-height: 100vh;
  width: 100vw;
  border: 0;
  display: block;
}
  </style>
</head>
<body>
  <script>

function configureFrame() {
  const sceneName = window.location.hash.substr(1) || window.location.search.substr(1);
  if (!sceneName) {
    throw new Error('no scene provided');
  }
  const staticPath = document.body.getAttribute('data-static') || '';
  const m = staticPath.match(/^(.*)(\/[^\/]*)$/);
  if (!m) {
    throw new Error(`couldn't match static path: ${staticPath}`);
  }

  const iframe = document.createElement('iframe');
  iframe.setAttribute('allow', 'accelerometer; autoplay; camera; fullscreen; encrypted-media; gyroscope; picture-in-picture; speaker; unsized-media');
  iframe.setAttribute('allowfullscreen', '');
  console.info('setting inner frame src', iframe.src);
  iframe.src = `${m[1]}/scenes/${sceneName}/${document.documentElement.lang || 'index'}.html`;
  document.body.appendChild(iframe);
  return iframe;
}

function post(port, message) {
  if (port) {
    if (typeof message !== 'string') {
      message = JSON.stringify(message);
    }
    port.postMessage(message);
  }
}

async function run() {
  const embedPort = await matchWindowMessage((ev) => {
    // nb. data should be 'santaandroid'
    if (ev.ports && ev.ports[0]) {
      console.info('got port from', ev.source);
      return ev.ports[0];
    }
  });

  const iframe = await configureFrame();
  const gamePort = await matchWindowMessage((ev) => {
    if (ev.source === iframe.contentWindow && ev.data === 'game') {
      return ev.ports[0];
    }
  });

  embedPort.onmessage = (ev) => {
    console.debug('got data from embed', ev.data);
    switch (ev.data) {
      // TODO: lazy-load Klang frame if unmuted
      case 'unmute':
        break;
      case 'mute':
        break;
      default:
        gamePort.postMessage(ev.data);
    }
  };

  gamePort.onmessage = (ev) => {
    console.info('posting to embed', ev.data);
    post(embedPort, ev.data);
  };
}


/**
 * @param {function(!Event): ?MessagePort} check to run
 * @return {!Promise<!MessagePort>}
 */
function matchWindowMessage(check) {
  return new Promise((resolve) => {
    const handler = (ev) => {
      const out = check(ev);
      if (out != null) {
        resolve(out);
        window.removeEventListener('message', handler);
      }
    };
    window.addEventListener('message', handler);
  });
}


run().catch((err) => {
  throw err;
});

  </script>
</body>
</html>