<!--
Copyright 2015 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../../components/polymer/polymer.html">

<link rel="import" href="lazy-pages_module.html">

<!--
Lazy loads children "pages".
-->
<dom-module id="lazy-pages">
  <template>
    <style include="lazy-pages_module"></style>
    <div hidden>
      <!-- low-key preloading -->
      <img src$="[[importPath]]img/snowman.png" />
      <img src$="[[importPath]]img/lock.svg" />
    </div>
    <div id="error" class$="[[_computeErrorClass(error)]]">
      <div class="icon">
        <div class="bg" style$="[[_computeLockStyle(error)]]"></div>
        <div class="lock"></div>
      </div>
      <p class="error">
        <i18n-msg msgid="error">PLACEHOLDER_i18n</i18n-msg>
      </p>
      <p class="network">
        <i18n-msg msgid="error-lost-connection">PLACEHOLDER_i18n</i18n-msg>
      </p>
      <p class="missing">
        <i18n-msg msgid="error-not-found">PLACEHOLDER_i18n</i18n-msg>
      </p>
    </div>
    <div id="scene" on-scene-progress="_onSceneProgress"></div>
  </template>
  <script>
(function() {

  /**
   * @type {!Object<string, number>} path to count of load failures
   */
  const failedToLoad = {};

  /**
   * @type {!WeakMap<!HTMLElement, !HTMLElement>} bimap of draft to the real element
   */
  const draftMap = new WeakMap();

  /**
  * @type {!WeakMap<!HTMLElement, number>} weak map of drafts to scroll positions
   */
  const scrollFromTop = new WeakMap();

  Polymer({
    is: 'lazy-pages',

    properties: {

      /**
       * The error state (if any). An object of {route: String, type: String}.
       */
      error: {
        type: Object,
        readOnly: true,
        value: null,
      },

      /**
       * An object of route name to draft scene element.
       */
      drafts: {
        type: Object,
        readOnly: true,
      },

      /**
       * The string of the selected route. This changes after a successful load.
       */
      route: {
        type: String,
        notify: true,
        observer: '_routeChanged',
      },

      /**
       * The current loading progress, as per `preload-bar`: in the range [0,1] or null.
       */
      progress: {
        type: Number,
        notify: true,
        readOnly: true,
      },

      /**
       * The scene that is being loaded via hard URL change, and no other scene is visible.
       */
      bootstrap: {
        type: Object,
        notify: true,
        computed: '_computeBootstrap(_pendingDraft, selectedItem, error)',
      },

      /**
       * The draft that is currently pending, if any.
       */
      _pendingDraft: {
        type: Object,
        value: null,
      },

      /**
       * The current live scene.
       */
      selectedItem: {
        type: Object,
        notify: true,
        readOnly: true,
        observer: '_selectedItemChanged',
      },

      /**
       * The current object/nonce identifying the active load. If this changes, then callbacks
       * should be dropped.
       */
      _loadingPromise: {
        type: Object,
        value: Promise.resolve(null),
      },

    },

    attached: function() {
      this._observer = Polymer.dom(this).observeNodes(this._updateDrafts);
      this._updateDrafts();
    },

    detached: function() {
      Polymer.dom(this).unobserveNodes(this._observer);
      this._setDrafts(null);
      this._setSelectedItem(null);
    },

    _onSceneProgress: function(ev) {
      const source = Polymer.dom(ev).path[0];
      if (source.hasAttribute('preload')) {
        this._setProgress(ev.detail);
      }
    },

    /**
     * Revalidate the currently selected scene, if any. May either load or unload the scene.
     */
    revalidate: function() {
      const route = this.route;
      const draft = this.getDraft(route);
      const draftForSelectedItem = draftMap.get(this.selectedItem);

      if (draft === draftForSelectedItem) {
        if (this._routeIsOpen(route)) { return; }

        // possibly close route
        this._setSelectedItem(null);
        this.load(route);
      } else {
        // will reload if selectedItem is null
        this._routeChanged(route);
      }
    },

    _routeChanged: function(route) {
      if (route === undefined) {
        return;  // ignore
      }

      const draft = this.getDraft(route);
      if (draftMap.get(this.selectedItem) !== draft) {
        this._setSelectedItem(null);  // immediately revoke the current scene
        this.load(route);
      }
    },

    load: function(route) {
      const draft = this.getDraft(route);
      if (draft && this._pendingDraft === draft) {
        return;  // already loading
      }

      const preloading = this.$.scene.querySelector('[preload]');
      preloading && preloading.remove();  // stop previous load

      if (draftMap.get(this.selectedItem) === draft) {
        this._pendingDraft = null;
        this._loadingPromise = Promise.resolve(this.selectedItem);
        this._setProgress(null);
        return;  // already _loaded_
      }
      this._pendingDraft = draft;
      this._setProgress(0);

      let p = null;  // nb. declared here so safe() can use it
      const safe = (fn) => {
        return function() {
          // nb. this is explicitly .bind() as it passes arguments
          if (this._loadingPromise === p) {
            return fn.apply(this, arguments);
          }
        }.bind(this);
      };

      const init = () => {
        if (!this._routeIsOpen(route)) {
          return Promise.reject('locked');
        } else if (!draft) {
          return Promise.reject('missing');
        }
        return this._loadFromDraft(draft).then(safe((scene) => {
          // wait for scene.preload, then return scene
          scene.setAttribute('preload', '');
          this.$.scene.appendChild(scene);
          if (scene.preload) {
            return scene.preload.then(() => scene);
          }
          console.debug('got scene without preload', scene.localName);
          return scene;
        }));
      };

      p = this._loadingPromise = init().then(safe(function(scene) {
        this._setSelectedItem(scene);  // actually preloaded (or null), so set item
        this._setError(null);

        // log that the scene has finished preloading. If this wasn't a preloaded
        // load, the event will be discarded harmlessly (no start event).
        const detail = {category: 'Scene Load Time', variable: route, time: Date.now()};
        this.fire('analytics-time-end', detail);
        return scene;
      }));

      const caught = p.catch(safe(function(reason) {
        console.warn('lazy-pages', route, 'failure', reason);
        if (reason !== 'locked') {
          // embed doesn't want to know about "locked"
          this.fire('embed', 'onfailure');
        }
        this._setSelectedItem(null);

        const error = {type: (typeof reason === 'string' ? reason : 'error'), route: route};
        this._setError(Object.freeze(error));
        if (typeof reason !== 'string') {
          throw reason;
        }
      }));

      // Regardless of outcome, clear progress outcome/_pendingItem on completion.
      caught.catch(() => {}).then(safe(function() {
        this._pendingDraft = null;
        this.route = route;  // always set route
        this._setProgress(null);
      }));
    },

    /**
     * Updates the `scenes` property based on the current DOM contents.
     */
    _updateDrafts: function() {
      const nodes = Polymer.dom(this).queryDistributedElements('[route]');
      const drafts = {};

      for (let i = 0; i < nodes.length; ++i) {
        const node = nodes[i];
        const draft = draftMap.get(node) || node;
        const route = draft.getAttribute('route');
        if (route) {
          drafts[route] = draft;
        }
      }

      this._setDrafts(Object.freeze(drafts));
    },

    _selectedItemChanged: function(newValue, oldValue) {
      if (oldValue) {
        const scrollTop = window.scrollY;
        if (scrollTop > 0) {
          // Save the scroll position (midpoint of the page) if it was >0.
          const draft = draftMap.get(oldValue);
          scrollFromTop.set(draft, scrollTop + (window.innerHeight / 2));
        }
        this.$.scene.removeChild(oldValue);
      }

      if (!newValue) { return; }

      if (this.$.scene !== newValue.parentNode) {
        throw new Error('expected selectedItem to be parented at scene')
      }
      newValue.removeAttribute('preload');

      const draft = draftMap.get(newValue);
      const scrollTopMid = scrollFromTop.get(draft);
      scrollFromTop.delete(draft);
      if (scrollTopMid !== undefined) {
        const scrollTop = scrollTopMid - (window.innerHeight / 2);
        window.requestAnimationFrame(function() {
          // this needs to happen in rAF, otherwise the browser might take over.
          window.scrollTo(0, scrollTop);
        });
      }
    },

    /**
     * Returns the scene draft with the specified route.
     */
    getDraft(route) {
      return this.drafts && this.drafts[route] || null;
    },

    /**
     * Creates a new element based on the passed draft element, possibly loading its corresponding
     * HTML import into the page.
     */
    _loadFromDraft: function(draft) {
      function create() {
        const real = draft.cloneNode(true);
        draftMap.set(real, draft);
        return real;
      }

      // This is already a real element, return early.
      if (customElements.get(draft.localName)) {
        return Promise.resolve(create());
      }

      // This element might still be part of the DOM: replace it with a placeholder so it's not
      // automatically instantiated by the browser.
      if (draft.parentNode === this) {
        const placeholder = document.createElement('dom-placeholder');
        placeholder.setAttribute('route', draft.getAttribute('route'));
        Polymer.dom(this).replaceChild(placeholder, draft);
        draftMap.set(placeholder, draft);
      }

      // Grab path from 'path' or 'path$'. The latter is needed as Polymer won't correctly map
      // attributes that have no bindings (e.g. path$="foo" => path$, path$="{{foo}}" => path).
      const path = draft.getAttribute('path') || draft.getAttribute('path$');
      if (!path) {
        return Promise.reject('path');
      }

      // Start scene loading time. Ended in the Promise callback inside `.load()`.
      const detail =
          {category: 'Scene Load Time', variable: draft.getAttribute('route'), time: Date.now()};
      this.fire('analytics-time-start', detail);

      return new Promise((resolve, reject) => {
        // Work around Polymer's failure to reload failed imports:
        //   https://github.com/Polymer/polymer/issues/3908
        // Append a numbered suffix if this is a 2nd failed load. This is stripped in the SW.
        const attempt = failedToLoad[path] || 0;
        const attemptSuffix = attempt ? '?' + attempt : '';
        const resolvedPath = this.resolveUrl('../../' + path);
        this.importHref(resolvedPath + attemptSuffix, function() {
          if (customElements.get(draft.localName)) {
            // Great! Yield back to the caller. Load timing ends in SantaSceneBehavior, as it
            // includes all resource preloading.
            resolve(create())
          } else {
            reject('element');
          }
        }, function(e) {
          failedToLoad[path] = attempt + 1;
          reject('network');
        });
      });
    },

    /**
     * @param {string} route to check if open
     * @return {boolean} is this route open
     */
    _routeIsOpen: function(route) {
      const event = this.fire('beforeload', route, {cancelable: true});
      return !event.defaultPrevented;
    },

    _computeBootstrap: function(pendingItem, selectedItem, error) {
      if (selectedItem || error) {
        return null;
      }
      return pendingItem;
    },

    _computeErrorClass: function(error) {
      if (error) {
        return 'error error-' + error.type;
      }
      return null;
    },

    _computeLockStyle: function(error) {
      if (!error || error.type !== 'locked') {
        return null;
      }
      // show background only if scene is locked
      const url = this.resolveUrl('../../images/scenes/' + error.route + '_2x.png');
      return 'background-image: url(' + url + ');'
    },

  });

}());
  </script>
</dom-module>
