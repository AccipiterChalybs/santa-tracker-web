<!--
Copyright 2015 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../../components/polymer/polymer.html">

<link rel="import" href="lazy-pages_module.html">

<!--
Lazy loads children "pages".
-->
<dom-module id="lazy-pages">
  <template>
    <style include="lazy-pages_module"></style>
    <div hidden>
      <!-- low-key preloading -->
      <img src$="[[importPath]]img/snowman.png" />
      <img src$="[[importPath]]img/lock.svg" />
    </div>
    <div id="error" class$="[[_computeErrorClass(error)]]">
      <div class="icon">
        <div class="bg" style$="[[_computeLockStyle(error)]]"></div>
        <div class="lock"></div>
      </div>
      <p class="error">
        <i18n-msg msgid="error">PLACEHOLDER_i18n</i18n-msg>
      </p>
      <p class="network">
        <i18n-msg msgid="error-lost-connection">PLACEHOLDER_i18n</i18n-msg>
      </p>
      <p class="missing">
        <i18n-msg msgid="error-not-found">PLACEHOLDER_i18n</i18n-msg>
      </p>
    </div>
    <slot name="santa-scene"></slot>
  </template>
  <script>
(function() {
  const failedToLoad = {};
  const retainAttr = Object.freeze([
    'route', 'mode', 'allow-page-scrolling', 'header-color', 'feature-color', 'youtube-id', 'hero-src', 'logo', 'slot',
  ]);

  /**
   * @param {!HTMLElement} scene
   * @return {!HTMLElement} the clone of scene, if needed
   */
  function maybeCloneScene(scene) {
    throw new Error('unused');
    if (scene.hasAttribute('permanent')) {
      return scene;  // don't need to recreate it
    }
    console.info('cloning', scene.localName);
    // Re-construct removed scene as it's e.g. a game that destructively modifies its DOM. Note
    // that loading-* isn't copied, since the element is already loaded.
    const clone = document.createElement(scene.localName);
    retainAttr.forEach(function(attr) {
      if (scene.hasAttribute(attr)) {
        clone.setAttribute(attr, scene.getAttribute(attr));
      }
    });
    return clone;
  }

  const placeholderMap = new WeakMap();

  Polymer({
    is: 'lazy-pages',

    properties: {

      /**
       * The error state (if any). An object of {route: String, type: String}.
       */
      error: {
        type: Object,
        readOnly: true,
        value: null,
      },

      /**
       * An object of route name to scene element.
       */
      scenes: {
        type: Object,
        readOnly: true,
      },

      /**
       * The string of the selected route. This changes after a successful load.
       */
      route: {
        type: String,
        notify: true,
        observer: '_routeChanged',
      },

      /**
       * The current loading progress, as per `preload-bar`: in the range [0,1] or null.
       */
      progress: {
        type: Number,
        notify: true,
        readOnly: true,
      },

      /**
       * The scene that is currently pending.
       */
      _pendingItem: {
        type: Object,
        value: null,
      },

      /**
       * The scene that is being loaded via hard URL change, and no other scene is visible.
       */
      bootstrap: {
        type: Object,
        notify: true,
        computed: '_computeBootstrap(_pendingItem, selectedItem, error)',
      },

      /**
       * The current live scene.
       */
      selectedItem: {
        type: Object,
        notify: true,
        readOnly: true,
        observer: '_selectedItemChanged',
      },

      /**
       * The current object/nonce identifying the active load. If this changes, then callbacks
       * should be dropped.
       */
      _loadingPromise: {
        type: Object,
        value: Promise.resolve(null),
      },

      /**
       * Stores scroll locations (from top), to restore on reload.
       */
      _scrollFromTop: {
        type: Object,
        value: function() { return new WeakMap(); },
      },

    },

    listeners: {
      'scene-progress': 'onSceneProgress',
    },

    attached: function() {
      this._observer = Polymer.dom(this).observeNodes(this._updateScenes);
      this._updateScenes();
    },

    detached: function() {
      Polymer.dom(this).unobserveNodes(this._observer);
      this._setScenes(null);
      this._setSelectedItem(null);
    },

    onSceneProgress: function(ev) {
      if (this._pendingItem === ev.path[0]) {
        this._setProgress(ev.detail);  // only update if the correct scene is dispatching events
      }
    },

    /**
     * Revalidate the currently selected scene, if any. May either load or unload the scene.
     */
    revalidate: function() {
      const route = this.route;
      const p = this._loadingPromise;

      const handler = (scene) => {
        if (p !== this._loadingPromise) {
          return this.revalidate();  // something changed, try again
        }

        if (scene === this.getRoute(route)) {
          // possibly close route
          if (!this._routeIsOpen(route)) {
            this._setSelectedItem(null);
            this.load(route);
          }
        } else {
          // will reload if selectedItem is null
          this._routeChanged(route);
        }
      };

      return this._loadingPromise.catch(() => {}).then(handler);
    },

    _routeChanged: function(route) {
      if (route === undefined) {
        return;  // ignore
      }

      const scene = this.getRoute(route);
      if (scene !== this.selectedItem) {
        this._setSelectedItem(null);  // immediately revoke the current scene
        this.load(route);
      }
    },

    load: function(route) {
      const scene = this.getRoute(route);
      if (scene && (this.selectedItem === scene || this._pendingItem === scene)) {
        return;  // already loaded or loading
      }

      let p = null;  // nb. declared here so safe() can use it
      const safe = (fn) => {
        return function() {
          if (this._loadingPromise === p) {
            return fn.apply(this, arguments);
          }
        }.bind(this);
      };

      let upgradedScene = null;
      const init = () => {
        if (!this._routeIsOpen(route)) {
          return Promise.reject('locked');
        } else if (!scene) {
          return Promise.reject('missing');
        }
        return this._loadScene(scene).then((x) => {
          upgradedScene = x;
          return x.preload;
        });
      };

      if (this._pendingItem) {
        this._ensurePlaceholderFor(this._pendingItem);
      }
      this._pendingItem = scene;
      p = this._loadingPromise = init().then(safe(function() {
        this._setSelectedItem(upgradedScene);  // actually preloaded (or null), so set item
        this._setError(null);

        // log that the scene has finished preloading. If this wasn't a preloaded
        // load, the event will be discarded harmlessly (no start event).
        this.fire('analytics-time-end', {category: 'Scene Load Time',
            variable: route, time: Date.now()});
        return scene;
      }));

      const caught = p.catch(safe(function(reason) {
        console.warn('lazy-pages', scene && scene.localName, 'failure', reason);
        this.fire('embed', 'onfailure');
        this._setSelectedItem(null);

        const error = {type: (typeof reason === 'string' ? reason : 'error'), route: route};
        this._setError(Object.freeze(error));
        if (typeof reason !== 'string') {
          throw reason;
        }
      }));

      // Regardless of outcome, clear progress outcome/_pendingItem on completion.
      caught.catch(() => {}).then(safe(function() {
        this.route = route;  // always set route
        this._setProgress(null);
        this._pendingItem = null;
      }));
    },

    /**
     * Updates the `scenes` property based on the current DOM contents.
     */
    _updateScenes: function() {
      const nodes = Polymer.dom(this).queryDistributedElements('[route]');
      const scenes = {};

      for (let i = 0; i < nodes.length; ++i) {
        const node = nodes[i];
        const scene = placeholderMap.get(node) || node;
        const route = scene.getAttribute('route');
        if (route) {
          scenes[route] = scene;
        }
      }

      this._setScenes(Object.freeze(scenes));
    },

    /**
     * Returns the scene with the specified route.
     */
    getRoute: function(route) {
      return this.scenes && this.scenes[route] || null;
    },

    _selectedItemChanged: function(newValue, oldValue) {
      if (oldValue) {
        const scrollTop = window.scrollY;
        if (scrollTop > 0) {
          // Save the scroll position (midpoint of the page) if it was >0.
          this._scrollFromTop.set(oldValue, scrollTop + (window.innerHeight / 2));
        }

        oldValue.removeAttribute('active');
        this._ensurePlaceholderFor(oldValue);
      }

      if (newValue) {
        const placeholder = placeholderMap.get(newValue);
        if (placeholder) {
          placeholderMap.delete(newValue);
          Polymer.dom(this).replaceChild(newValue, placeholder);
        }

        newValue.setAttribute('active', '');

        const scrollTopMid = this._scrollFromTop.get(newValue);
        this._scrollFromTop.delete(newValue);
        if (scrollTopMid !== undefined) {
          const scrollTop = scrollTopMid - (window.innerHeight / 2);
          window.requestAnimationFrame(function() {
            // this needs to happen in rAF, otherwise the browser might take over.
            window.scrollTo(0, scrollTop);
          });
        }
      }
    },

    /**
     * Loads the HTML import for the underlying scene based on its `path` attribute. If the scene
     * is already a real Custom Element, then resolves immediately.
     *
     * @param {!HTMLElement} scene
     * @return {!Promise<!HTMLElement>}
     */
    _loadScene: function(scene) {
      if (!scene || scene.is) {
        return Promise.resolve(scene);
      }

      // Grab path from 'path' or 'path$'. The latter is needed as Polymer won't correctly map
      // attributes that have no bindings (e.g. path$="foo" => path$, path$="{{foo}}" => path).
      const path = scene.getAttribute('path') || scene.getAttribute('path$');
      if (!path) {
        return Promise.reject('path');
      }

      // Start scene loading time.
      const route = scene.getAttribute('route') || scene.route;
      this.fire('analytics-time-start', {category: 'Scene Load Time',
          variable: route, time: Date.now()});

      // Ensure this is a placeholder, so it doesn't ...
      this._ensurePlaceholderFor(scene);

      return new Promise((resolve, reject) => {
        // Work around Polymer's failure to reload failed imports:
        //   https://github.com/Polymer/polymer/issues/3908
        // Append a numbered suffix if this is a 2nd failed load. This is stripped in the SW.
        const attempt = failedToLoad[path] || 0;
        const attemptSuffix = attempt ? '?' + attempt : '';
        const resolvedPath = this.resolveUrl('../../' + path);
        this.importHref(resolvedPath + attemptSuffix, function() {
          // Great! Yield back to the caller. Load timing ends in SantaSceneBehavior, as it
          // includes all resource preloading.
          if (customElements.get(scene.localName)) {
            resolve(this._upgradeScene(scene));
          } else {
            reject('element');
          }
        }, function(e) {
          failedToLoad[path] = attempt + 1;
          reject('network');
        });
      });
    },

    _ensurePlaceholderFor: function(scene) {
      const existing = placeholderMap.get(scene);
      if (existing || scene.parentNode !== this) {
        return existing;
      }

      const placeholder = document.createElement('dom-placeholder');
      placeholder.setAttribute('route', scene.getAttribute('route'));
      placeholderMap.set(placeholder, scene);
      placeholderMap.set(scene, placeholder);
      Polymer.dom(this).replaceChild(placeholder, scene);
    },

    _upgradeScene: function(scene) {
      if (scene.is) {
        return scene;
      }
      const replacement = document.createElement(scene.localName);

      const placeholder = placeholderMap.get(scene);
      placeholderMap.delete(scene);
      placeholderMap.set(placeholder, replacement);
      placeholderMap.set(replacement, placeholder);

      return replacement;
    },

    /**
     * @param {string} route to check if open
     * @return {boolean} is this route open
     */
    _routeIsOpen: function(route) {
      const event = this.fire('beforeload', route, {cancelable: true});
      return !event.defaultPrevented;
    },

    _computeBootstrap: function(pendingItem, selectedItem, error) {
      if (selectedItem || error) {
        return null;
      }
      return pendingItem;
    },

    _computeErrorClass: function(error) {
      if (error) {
        return 'error error-' + error.type;
      }
      return null;
    },

    _computeLockStyle: function(error) {
      if (!error || error.type !== 'locked') {
        return null;
      }
      // show background only if scene is locked
      const url = this.resolveUrl('../../images/scenes/' + error.route + '_2x.png');
      return 'background-image: url(' + url + ');'
    },

  });

}());
  </script>
</dom-module>
