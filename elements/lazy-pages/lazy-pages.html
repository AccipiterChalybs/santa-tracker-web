<!--
Copyright 2015 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../../components/polymer/polymer.html">

<!--
Lazy loads children "pages".
-->
<dom-module id="lazy-pages">
  <template>
    <style>
      :host {
        position: static;
        display: block;
      }
      :host ::slotted(*) {
        position: absolute;
        top: 44px;
        right: 0;
        bottom: 0;
        left: 0;
        overflow: hidden;  /* explicitly only needed for iOS */
      }
      :host ::slotted([allow-page-scrolling]) {
        top: 0;
        bottom: auto;
        overflow: auto;
      }
      :host ::slotted(*:focus) {
        outline: none;
      }
      :host ::slotted(*:not([active])) {
        display: none !important;
      }

      [hidden] {
        display: none !important;
      }
      #error {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        min-height: 100vh;
        box-sizing: border-box;

        display: flex;
        align-items: center;
        justify-content: center;
        flex-flow: column;
        background: url(img/error.svg) bottom center no-repeat;
        background-size: cover;
      }
      #error:not([class]) {
        display: none;
      }
      .icon {
        position: relative;
        width: 250px;
        height: 250px;
        border-radius: 10000px;
        box-shadow: 4px 14px 0 rgba(0,0,0,.125);
        background: #7ec6e5 url(img/snowman.png) center no-repeat;
        background-size: 179px 214px;
        overflow: hidden;
      }
      .icon .bg {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: transparent center no-repeat;
        background-size: cover;
      }
      .icon::before {
        content: '';
        z-index: 1000;
        position: absolute;
        width: 100%;
        height: 100%;
        border-radius: 10000px;
        background: rgba(0, 0, 0, 0.125) url(img/lock.svg) center no-repeat;
      }
      #error:not(.error-locked) .icon::before {
        display: none;
      }
      #error:not(.error-network) p.error {
        display: none;
      }
      #error:not(.missing) p.missing {
        display: none;
      }
      p {
        margin: 2em auto;
        max-width: 90%;
        color: white;
        font-size: 16px;
        line-height: 28px;
        text-align: center;
      }
      @media (max-height: 400px) {
        #error {
          flex-flow: row;
        }
        #error p {
          margin: 0 2em;
        }
        .icon {
          width: 192px;
          height: 192px;
          min-width: 192px;
          margin: 0 1em;
        }
      }
    </style>
    <div hidden>
      <!-- low-key preloading -->
      <img src$="[[importPath]]img/snowman.png" />
      <img src$="[[importPath]]img/lock.svg" />
    </div>
    <div id="error" class$="[[_computeErrorClass(selectedItem, error)]]">
      <div class="icon">
        <div class="bg" style$="[[_computeLockStyle(route, error)]]"></div>
        <div class="lock"></div>
      </div>
      <p class="error">
        <i18n-msg msgid="error">PLACEHOLDER_i18n</i18n-msg>
      </p>
      <p class="missing">
        <!-- TODO: stuff -->
        Can't find this page!
      </p>
    </div>
    <slot name="santa-scene"></slot>
  </template>
  <script>
(function() {
  const failedToLoad = {};
  const retainAttr = Object.freeze([
    'route', 'mode', 'allow-page-scrolling', 'header-color', 'feature-color', 'youtube-id', 'hero-src', 'logo', 'slot',
  ]);

  /**
   * @param {!HTMLElement} scene
   * @return {!HTMLElement} the clone of scene, if needed
   */
  function maybeCloneScene(scene) {
    if (scene.hasAttribute('permanent')) {
      return scene;  // don't need to recreate it
    }
    // Re-construct removed scene as it's e.g. a game that destructively modifies its DOM. Note
    // that loading-* isn't copied, since the element is already loaded.
    const clone = document.createElement(scene.localName);
    retainAttr.forEach(function(attr) {
      if (scene.hasAttribute(attr)) {
        clone.setAttribute(attr, scene.getAttribute(attr));
      }
    });
    // TODO(samthor): Otherwise, the scene itself triggers the `scene-progress` event.
    clone.loaded = true;
    return clone;
  }

  Polymer({
    is: 'lazy-pages',

    properties: {

      /**
       * The error state (if any). Should be null or "network", "locked" etc.
       */
      error: {
        type: String,
        readOnly: true,
        value: null,
      },

      /**
       * An object of route name to scene element.
       */
      scenes: {
        type: Object,
        readOnly: true,
      },

      /**
       * The selected string route.
       */
      route: {
        type: String,
        observer: '_routeChanged',
      },

      /**
       * The computed selectedItem.
       */
      selectedItem: {
        type: Object,
        notify: true,
        readOnly: true,
        observer: '_selectedItemChanged',
      },

      /**
       * The current object/nonce identifying the active load. If this changes, then callbacks
       * should be dropped.
       */
      _loadingPromise: {
        type: Object,
      },

    },

    attached: function() {
      this._observer = Polymer.dom(this).observeNodes(this._updateScenes);
      this._updateScenes();
    },

    detatched: function() {
      Polymer.dom(this).unobserveNodes(this._observer);
      this._setScenes(null);
      this._setSelectedItem(null);
    },

    /**
     * Revalidate the currently selected scene, if any. May either load or unload the scene.
     */
    revalidate: function() {
      this._routeChanged(this.route);
    },

    _updateScenes: function() {
      const nodes = Polymer.dom(this).queryDistributedElements('[route]');
      const scenes = {};

      for (let i = 0; i < nodes.length; ++i) {
        const scene = nodes[i];
        const route = scene.getAttribute('route');
        if (route) {
          scenes[route] = scene;
        }
      }

      const previousPossibleScene = this.getRoute(this.selected);
      const candidateScene = scenes[this.selected] || null;
      this._setScenes(Object.freeze(scenes));
    },

    /**
     * Returns the scene with the specified route.
     */
    getRoute: function(route) {
      return this.scenes && this.scenes[route] || null;
    },

    _routeChanged: function(route) {
      this._setError(null);

      const scene = this.getRoute(route);
      if (scene && !this._routeIsOpen(route)) {
        this._setSelectedItem(null);
        return this._setError('locked');
      } else if (this.selectedItem === scene && (scene && scene.is)) {
        return;  // done
      }

      this._setSelectedItem(scene);  // possibly null
      this._loadingPromise = this._loadScene();  // runs here to kickoff 'scene-progress'
    },

    _selectedItemChanged: function(newValue, oldValue) {
      if (oldValue) {
        oldValue.removeAttribute('active');

        const scene = maybeCloneScene(oldValue);
        Polymer.dom(this).replaceChild(scene, oldValue);
      }

      if (newValue) {
        newValue.setAttribute('active', '');
      }
    },

    _loadScene: function() {
      const scene = this.selectedItem;
      if (!scene || scene.loaded) { return null; }

      // Grab path from 'path' or 'path$'. The latter is needed as Polymer won't correctly map
      // attributes that have no bindings (e.g. path$="foo" => path$, path$="{{foo}}" => path).
      const path = scene.getAttribute('path') || scene.getAttribute('path$');
      if (!path) { return null; }

      // Start scene loading time.
      var route = scene.getAttribute('route') || scene.route;
      this.fire('analytics-time-start', {category: 'Scene Load Time',
          variable: route, time: Date.now()});

      // (Re)set the preload bg color and loading image before scene is loaded.
      this.fire('scene-progress');

      // TODO: Return a real promise.
      const p = {};

      // Work around Polymer's failure to reload failed imports:
      //   https://github.com/Polymer/polymer/issues/3908
      // Append a numbered suffix if this is a 2nd failed load. This is stripped in the SW.
      const attempt = failedToLoad[path] || 0;
      const attemptSuffix = attempt ? '?' + attempt : '';
      const resolvedPath = this.resolveUrl('../../' + path);
      this.importHref(resolvedPath + attemptSuffix, function() {
        // Great! Nothing else to do here. Load timing ends in SantaSceneBehavior, as it includes
        // all resource preloading.
      }, function(e) {
        failedToLoad[path] = attempt + 1;
        if (this._loadingPromise !== p) {
          return;  // something changed
        }
        console.warn('unable to load path', path);
        this._setError('network');
        this.fire('scene-failure');
      }.bind(this));

      return p;
    },

    /**
     * @param {string} route to check if open
     * @return {boolean} is this route open
     */
    _routeIsOpen: function(route) {
      const event = this.fire('beforeload', route, {cancelable: true});
      return !event.defaultPrevented;
    },

    _computeErrorClass: function(selected, error) {
      if (error) {
        return 'error error-' + error;
      } else if (selected === null) {  // not undefined
        return 'missing';
      }
      return null;
    },

    _computeLockStyle: function(route, error) {
      if (!route || error === 'network') {
        return null;
      }
      const url = this.resolveUrl('../../images/scenes/' + route + '_2x.png');
      return 'background-image: url(' + url + ');'
    },

  });

}());
  </script>
</dom-module>
