<!--
Copyright 2017 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../components/polymer/polymer.html">
<link rel="import" href="../components/google-apis/google-youtube-api.html">
<link rel="import" href="../components/iron-icon/iron-icon.html">
<link rel="import" href="santa-icons.html">

<!--
Video element that wraps up the YouTube API. This is more lightweight than the <google-youtube>
element, and does not support e.g. queuing or other mechanics. It hides/disables the default
YouTube API as much as possible.

This is used via an imperative API, rather than a delcarative "youtube-id" attribute. Call
`.play(videoId)` to immediately play a video, and `.cue(videoId)` to set up a video for the user to
later hit "play" on. This is potentially required for mobile browsers which don't allow autoplay.
-->
<dom-module id="santa-video">
<template>
  <style>
    :host {
      display: block;
      position: relative;
      width: 100%;
      height: 100%;
      background: black;
    }
    #holder, #player {
      width: 100%;
      height: 100%;
    }
    #holder {
      overflow: hidden;
      pointer-events: none;
      background: var(--santa-video-background, #21a34a);
      border-radius: inherit;
    }
    #holder[hidden] {
      display: initial !important;
      visibility: hidden;
    }

    #overlay {
      cursor: pointer;
      border: 0;
      background: transparent;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 0;
      margin: 0;
    }

    #controls {
      z-index: 10;
      background: rgba(33, 33, 33, 0.125);
      opacity: 0;
      will-change: opacity;
      transition: opacity 0.25s;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #controls.hidden {
      visibility: hidden;
    }
    #controls.hidden, #controls.cued {
      opacity: 0 !important;  /* prevents transitions */
    }
    #controls.cued iron-icon {
      display: none !important;
    }

    /* only show hover where.. hover is supportedâ€”stops touch device emulating hover */
    /* TODO(samthor): Could we leverage :active on the button to do something useful */
    @media (hover: hover) {
      #controls:hover {
        opacity: 1;
      }
    }
    @media not (hover: hover) {
      iron-icon#pause {
        visibility: hidden;
      }
    }

    #controls {
      --iron-icon-fill-color: white;
      --iron-icon-width: 52px;
      --iron-icon-height: 52px;
    }
    #controls:not(.playing) {
      opacity: 1;
    }
    #controls:not(.playing) iron-icon#pause {
      display: none;
    }
    #controls.playing iron-icon#play {
      display: none;
    }
  </style>

  <!-- nb. use restamp to cause recreation when detached/attached -->
  <template is="dom-if" if="[[_anyVideoLoaded]]" restamp>
    <google-youtube-api on-api-load="_apiLoad"></google-youtube-api>
  </template>

  <div id="holder" hidden$="[[!active]]">
    <div id="player" tabindex="-1"></div>
  </div>
  <button id="overlay" on-click="_clickVideo">
    <div id="controls" class$="[[_computeOverlayClass(controls, active, playing, _cued)]]">
      <iron-icon id="pause" icon="santa:pause"></iron-icon>
      <iron-icon id="play" icon="santa:play"></iron-icon>
    </div>
  </button>

</template>
<script>
(function() {

// nb. YouTube player states are documented here:
//   https://developers.google.com/youtube/iframe_api_reference#Playback_status

// TODO(samthor): Preview images (similar to old -banner.jpg images) are here:
//   https://img.youtube.com/vi/VIDEOID/maxresdefault.jpg

function isPlayingState(state) {
  return state === 1 || state === 3;
}

Polymer({
  is: 'santa-video',

  properties: {

    /**
     * Controls and notifies whether this video is playing (as opposed to paused), if loaded
     * (this is ignored if no video is configured with `.load()` or `.cue()`).
     */
    playing: {
      type: Boolean,
      value: false,
      notify: true,
    },

    /**
     * Whether the player itself is active (playing, paused, caching which is visible).
     */
    active: {
      type: Boolean,
      readOnly: true,
      notify: true,
      value: false,
    },

    /**
     * Whether the player itself has started. This is a subset of `active`.
     */
    started: {
      type: Boolean,
      readOnly: true,
      notify: true,
      value: false,
    },

    /**
     * Whether to show the play/pause controls (`santa-video` is always clickable to play/pause).
     */
    controls: {
      type: Boolean,
      value: false,
    },

    /**
     * The ID of the video being played. This is changed via the imperative API.
     */
    videoId: {
      type: String,
      readOnly: true,
      notify: true,
      value: null,
    },

    /**
     * Whether to mute the video being played.
     */
    mute: {
      type: Boolean,
      value: false,
    },

    /**
     * The current active operation.
     */
    _op: {
      type: Object,
    },

    /**
     * Holds the global YouTube API object. Set via the _apiLoad method callback.
     */
    _api: {
      type: Object,
    },

    /**
     * Whether any video has been loaded. Controls loading the internal `google-youtube-api`.
     */
    _anyVideoLoaded: {
      type: Boolean,
      value: false,
    },

    /**
     * Holds the YT.Player instance.
     */
    _player: {
      type: Object,
      observer: '_onPlayerChange',
    },

    /**
     * Whether the YouTube player is currently cued.
     */
    _cued: {
      type: Boolean,
      value: false,
    },

  },

  observers: [
    '_preparePlayer(_player, _op)',
    '_updatePlaying(active, playing)',
    '_updateMute(_player, mute)',
  ],

  detached: function() {
    this.reset();  // nb. call first, to clear _op before player

    this._anyVideoLoaded = false;
    this._player = null;
    this._api = null;
  },

  /**
   * Loads and plays the specified YouTube video.
   */
  play: function(videoId) {
    this._anyVideoLoaded = true;
    this._op = {id: videoId, cue: false};
  },

  /**
   * Cues the specified YouTube video. Shows a preview image and waits for 'normal' user
   * interaction, which is probably required for iOS/other mobile interfaces.
   */
  cue: function(videoId) {
    this._anyVideoLoaded = true;
    const op = this._op = {id: videoId, cue: true};

    // TODO(samthor): This might not always resolve.
    return new Promise((resolve, reject) => {
      this.addEventListener('_active', function handler(ev) {
        this.removeEventListener('_active', handler);
        ev.detail === op ? resolve() : reject('op changed');
      });
    });
  },

  /**
   * Resets this `<santa-video>` to its initial state, not playing a video whatsoever. This does
   * _not_ destroy the internal YouTube API.
   */
  reset: function() {
    this._op = null;
  },

  _apiLoad: function(ev) {
    if (this._api === ev.target.api) {
      return;
    }
    this._api = ev.target.api;

    const vars = {
      playsinline: 1,
      cc_load_policy: 1,
      disablekb: 1,
      fs: 0,
      hl: document.documentElement.lang || 'en',
      controls: 0,
      modestbranding: 1,
      showinfo: 0,
      iv_load_policy: 3,
      rel: 0,
    };

    const player = new this._api.Player(this.$.player, {
      width: '100%',
      height: '100%',
      playerVars: vars,
      events: {
        onReady: (ev) => {
          this._player = player;
        },
        onStateChange: (ev) => {
          this._youtubeStateChange(ev.data);
        },
        onError: (ev) => {
          if (this._hasVideoUrl) {
            this.fire('youtube-error', ev);
          }
        },
      },
    });
    // don't save player: wait for onReady to be called
  },

  get _hasVideoUrl() {
    if (!this._player) {
      return false;
    }
    return this._player.getVideoUrl().indexOf('?v=') !== -1;
  },

  _youtubeStateChange: function(state) {
    const wasActive = this.active;

    if (state === 3 && !this.active) {
      // do nothing: we're preloading
    } else if (isPlayingState(state)) {
      // playing or paused
      this._setActive(true);
      this._setStarted(true);
    } else if (state === 5) {
      // cued
      this._setActive(true);
    } else if (state === 0) {
      // done
      this._op = null;
      this._setActive(false);
      this._setStarted(false);
    }

    if (!wasActive && this.active) {
      this.fire('_active', this._op, {bubbles: false});
    }

    this._cued = (state === 5);
  },

  _onPlayerChange: function(newValue, oldValue) {
    oldValue && oldValue.destroy();
  },

  _preparePlayer: function(player, op) {
    if (!player) { return; }

    if (this.isAttached) {
      player.nextVideo();
      player.loadVideoById();
    }
    this._setActive(false);
    this._setStarted(false);

    if (!op || !this.isAttached) {
      this._setVideoId(null);
      this.playing = false;
      return; // nothing else to do
    }

    if (op.cue) {
      player.cueVideoById(op.id);
    } else {
      player.loadVideoById(op.id);
    }
    this.playing = !op.cue;
    this._setVideoId(op.id);
  },

  _updatePlaying: function(active, playing) {
    if (!active) { return; }

    const player = this._player;  // if active==true, we must have a player
    const playerIsPlaying = isPlayingState(player.getPlayerState());
    if (playing === playerIsPlaying) {
      // do nothing
    } else if (playing) {
      player.playVideo();
    } else {
      player.pauseVideo();
    }
  },

  _updateMute: function(player, mute) {
    if (!player) { return; }

    if (mute) {
      player.mute();
    } else {
      player.unMute();
    }
  },

  _clickVideo: function() {
    this.playing = !this.playing;
  },

  _computeOverlayClass: function(controls, active, playing, cued) {
    if (!active) {
      return 'hidden';
    } else if (cued || !controls) {
      return 'cued';  // no controls piggybacks on cued
    } else if (playing) {
      return 'playing';
    } else {
      return '';
    }
  },
});

})();
</script>
</dom-module>