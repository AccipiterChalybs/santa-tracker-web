<!--
Copyright 2017 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../components/polymer/polymer.html">
<link rel="import" href="../components/google-apis/google-youtube-api.html">
<link rel="import" href="../components/iron-icon/iron-icon.html">
<link rel="import" href="santa-icons.html">

<!--
Video element that wraps up the YouTube API. This is more lightweight than the <google-youtube>
element, and does not support e.g. queuing or other mechanics. It hides/disables the default
YouTube API as much as possible.

This is used via an imperative API, rather than a delcarative "youtube-id" attribute. Call
`.play(videoId)` to immediately play a video, and `.cue(videoId)` to set up a video for the user to
later hit "play" on. This is potentially required for mobile browsers which don't allow autoplay.
-->
<dom-module id="santa-video">
<template>
  <style>
    :host {
      display: block;
      position: relative;
      width: 100%;
      height: 100%;
    }
    #holder, #player {
      width: 100%;
      height: 100%;
    }
    #holder {
      overflow: hidden;
      pointer-events: none;
      background: black;
    }
    #holder[hidden] {
      display: initial !important;
      visibility: hidden;
    }

    #overlay {
      cursor: pointer;
      border: 0;
      background: transparent;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      padding: 0;
      margin: 0;
    }

    #controls {
      z-index: 10;
      background: rgba(33, 33, 33, 0.125);
      opacity: 0;
      will-change: opacity;
      transition: opacity 0.25s;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #controls.hidden {
      visibility: hidden;
    }
    #controls.hidden, #controls.cued {
      opacity: 0 !important;  /* prevents transitions */
    }
    #controls.cued iron-icon {
      display: none !important;
    }

    /* only show hover where.. hover is supportedâ€”stops touch device emulating hover */
    /* TODO(samthor): Could we leverage :active on the button to do something useful */
    @media (hover: hover) {
      #controls:hover {
        opacity: 1;
      }
    }
    @media not (hover: hover) {
      iron-icon#pause {
        visibility: hidden;
      }
    }

    #controls {
      --iron-icon-fill-color: white;
      --iron-icon-width: 52px;
      --iron-icon-height: 52px;
    }
    #controls:not(.playing) {
      opacity: 1;
    }
    #controls:not(.playing) iron-icon#pause {
      display: none;
    }
    #controls.playing iron-icon#play {
      display: none;
    }
  </style>

  <google-youtube-api on-api-load="_apiLoad" id="loader"></google-youtube-api>

  <div id="holder" hidden$="[[!active]]">
    <div id="player" tabindex="-1"></div>
  </div>
  <button id="overlay" on-click="_clickVideo">
    <div id="controls" class$="[[_computeOverlayClass(controls, active, playing, _cued)]]">
      <iron-icon id="pause" icon="santa:pause"></iron-icon>
      <iron-icon id="play" icon="santa:play"></iron-icon>
    </div>
  </button>

</template>
<script>
(function() {

// nb. YouTube player states are documented here:
//   https://developers.google.com/youtube/iframe_api_reference#Playback_status

// TODO(samthor): Preview images (similar to old -banner.jpg images) are here:
//   https://img.youtube.com/vi/VIDEOID/maxresdefault.jpg

function isPlayingState(state) {
  return state === 1 || state === 3;
}

Polymer({
  is: 'santa-video',

  properties: {

    /**
     * Controls and notifies whether this video is playing (as opposed to paused), if loaded
     * (this is ignored if no video is configured with `.load()` or `.cue()`).
     */
    playing: {
      type: Boolean,
      value: false,
      notify: true,
    },

    /**
     * Whether the player itself is active (playing, paused, caching which is visible).
     */
    active: {
      type: Boolean,
      readOnly: true,
      notify: true,
      value: false,
    },

    /**
     * Whether to show the play/pause controls (`santa-video` is always clickable to play/pause).
     */
    controls: {
      type: Boolean,
      value: false,
    },

    /**
     * The current active operation.
     */
    _op: {
      type: Object,
    },

    /**
     * Holds the global YouTube API object. Set via the _apiLoad method callback.
     */
    _api: {
      type: Object,
    },

    /**
     * Holds the YT.Player instance.
     */
    _player: {
      type: Object,
      observer: '_onPlayerChange',
    },

    /**
     * Whether the YouTube player is currently cued.
     */
    _cued: {
      type: Boolean,
      value: false,
    },

  },

  observers: [
    '_preparePlayer(_player, _op)',
    '_updatePlaying(active, playing)',
  ],

  /**
   * Loads and plays the specified YouTube video.
   */
  play: function(videoId) {
    this._op = {id: videoId, cue: false};
  },

  /**
   * Cues the specified YouTube video. Shows a preview image and waits for 'normal' user
   * interaction, which is probably required for iOS/other mobile interfaces.
   */
  cue: function(videoId) {
    this._op = {id: videoId, cue: true};
  },

  /**
   * Resets this `<santa-video>` to its initial state, not playing a video whatsoever.
   */
  reset: function() {
    this._op = null;
  },

  _apiLoad: function() {
    if (this._api === this.$.loader.api) {
      return;
    }
    this._api = this.$.loader.api;

    const vars = {
      playsinline: 1,
      cc_load_policy: 1,
      disablekb: 1,
      fs: 0,
      hl: document.documentElement.lang || 'en',
      controls: 0,
      modestbranding: 1,
      showinfo: 0,
      iv_load_policy: 3,
      rel: 0,
    };

    const player = new this._api.Player(this.$.player, {
      width: '100%',
      height: '100%',
      playerVars: vars,
      events: {
        onReady: function(ev) {
          this._player = player;
        }.bind(this),
        onStateChange: function(ev) {
          this._youtubeStateChange(ev.data);
        }.bind(this),
        onError: function(ev) {
          if (this._hasVideoUrl) {
            this.fire('youtube-error', ev);
          }
        }.bind(this),
      },
    });
    // don't save player: wait for onReady to be called
  },

  get _hasVideoUrl() {
    if (!this._player) {
      return false;
    }
    return this._player.getVideoUrl().indexOf('?v=') !== -1;
  },

  _youtubeStateChange: function(state) {
    if (state === 3 && !this.active) {
      // do nothing: we're preloading
    } else if (isPlayingState(state) || state === 5) {
      this._setActive(true);
    } else if (state === 0) {
      this._op = null;
      this._setActive(false);
    }

    this._cued = (state === 5);
  },

  _onPlayerChange: function(newValue, oldValue) {
    oldValue && oldValue.destroy();
  },

  _preparePlayer: function(player, op) {
    if (!player) { return; }

    player.nextVideo();
    player.loadVideoById();
    this._setActive(false);

    if (!op) {
      // nothing else to do
    } else if (op.cue) {
      player.cueVideoById(op.id);
      this.playing = false;
    } else {
      player.loadVideoById(op.id);
      this.playing = true;
    }
  },

  _updatePlaying: function(active, playing) {
    if (!active) { return; }

    const player = this._player;  // if active==true, we must have a player
    const playerIsPlaying = isPlayingState(player.getPlayerState());
    if (playing === playerIsPlaying) {
      // do nothing
    } else if (playing) {
      player.playVideo();
    } else {
      player.pauseVideo();
    }
  },

  _clickVideo: function() {
    this.playing = !this.playing;
  },

  _computeOverlayClass: function(controls, active, playing, cued) {
    if (!active) {
      return 'hidden';
    } else if (cued || !controls) {
      return 'cued';  // no controls piggybacks on cued
    } else if (playing) {
      return 'playing';
    } else {
      return '';
    }
  },
});

})();
</script>
</dom-module>