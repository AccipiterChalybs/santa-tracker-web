<!--
Copyright 2015 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../../components/polymer/polymer.html">

<link rel="import" href="../../components/iron-a11y-keys/iron-a11y-keys.html">
<link rel="import" href="../../components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../santa-badge/santa-badge.html">
<link rel="import" href="../santa-chrome/santa-chrome.html">
<link rel="import" href="../santa-sidebar/santa-sidebar.html">
<link rel="import" href="../santa-tracker-router.html">
<link rel="import" href="../preloader/preload-bar.html">
<link rel="import" href="../lazy-pages/lazy-pages.html">
<link rel="import" href="../overlay/santa-overlay.html">
<link rel="import" href="../santa-strings.html">
<link rel="import" href="../hint/santa-hint.html">

<script src="../../js/config/houses.js"></script>
<script src="../../js/config/videos.js"></script>

<!--
Santa Tracker app.
-->
<dom-module id="santa-app">
<template>
  <style>
    :host {
      --link-visibility: visible;  /* piggyback [routing] from index to enable external links */
    }
    :host(:not([routing])) {
      --link-visibility: hidden;
      --link-display: none !important;
    }

    santa-overlay,
    santa-hint {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 200;  /* TODO(samthor): Workaround for scenes, which have UI/buttons in 1xx. */
      overflow: hidden;
    }
    santa-overlay::before {
      content: '';
      display: block;
      z-index: -1;
      background-color: var(--santa-header-color, #00c6ed);
      opacity: 0.9;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
  </style>

  <!-- Shared i18n strings -->
  <santa-strings id="strings"></santa-strings>

  <!-- Global singleton state -->
  <santa-state during-tracker="{{duringTracker}}"
      current-time="{{currentTime}}"
      requested-reload="{{requestedReload}}"></santa-state>

  <!-- Keyboard handler -->
  <iron-a11y-keys keys="esc enter" on-keys-pressed="_onKeysPressed"></iron-a11y-keys>

  <!-- Route controller -->
  <santa-tracker-router enabled="[[routing]]" route="{{route}}"></santa-tracker-router>

  <!-- Chrome, including toolbar and sidebar -->
  <santa-chrome id="chrome"
      disabled="[[omitSantaChrome(mode)]]"
      clients="[[clients]]"
      mute="{{userMute}}"
      pause="{{userPause}}">

    <santa-badge id="badge" slot="feature"></santa-badge>

    <santa-sidebar slot="drawer"></santa-sidebar>

    <santa-overlay id="overlay" hidden$="[[_computeOverlayHidden(userPause, mode)]]" next-route="[[nextRandom]]"></santa-overlay>

    <santa-hint hidden pause="{{userPause}}" route="[[_computeNextRandomForHint(nextRandom, route)]]"></santa-hint>

    <!-- Scenes -->
    <lazy-pages id="lazypages"
        mode$="[[mode]]"
        route="{{route}}"
        progress="{{_progress}}"
        selected-item="{{selectedScene}}"
        bootstrap="{{_bootstrap}}">

      <cast-scene route="cast"
          path$="scenes/cast/cast-scene_[[language]].html"
          allow-page-scrolling></cast-scene>

      <dorf-scene route="village" icon="1f384"
          path$="scenes/dorf/dorf-scene_[[language]].html"
          allow-page-scrolling></dorf-scene>

      <educators-scene route="educators" icon="1f3eb"
          path$="scenes/educators/educators-scene_[[language]].html"
          slot="santa-scene"
          allow-page-scrolling></educators-scene>

      <press-scene route="press" icon="1f4f0"
          path$="scenes/press/press-scene_[[language]].html"
          slot="santa-scene"
          allow-page-scrolling></press-scene>

      <!-- santaweb scenes -->

      <iframe-scene route="elfmaker" icon="1f9dd"
          path$="scenes/iframe/iframe-scene.html"
          slot="santa-scene"></iframe-scene>

      <iframe-scene route="poseboogie" icon="1f57a"
          path$="scenes/iframe/iframe-scene.html"
          slot="santa-scene"></iframe-scene>

      <!-- Keep scenes (non-village) ordered alphabetically -->

      <airport-scene route="airport" icon="1f6c4"
          path$="scenes/airport/airport-scene_[[language]].html"
          header-color="#fdbe27"
          feature-color="#83ce00"
          logo="scenes/airport/img/logo.svg"></airport-scene>

      <blimp-scene route="blimp" icon="1f6a1"
          path$="scenes/blimp/blimp-scene_[[language]].html"
          header-color="#575769"></blimp-scene>

      <boatload-scene route="boatload" icon="26f5"
          path$="scenes/boatload/boatload-scene_[[language]].html"
          loading-bg-color="#8fd7f7"
          loading-src="scenes/boatload/img/loading.svg"
          logo="scenes/boatload/img/logo.svg"></boatload-scene>

      <briefing-scene route="briefing" icon="1f634"
          path$="scenes/briefing/briefing-scene_[[language]].html"
          header-color="#007ab6"
          logo="scenes/briefing/img/logo.svg"></briefing-scene>

      <citylights-scene route="citylights" icon="1f306"
          path$="scenes/citylights/citylights-scene_[[language]].html"
          header-color="#575769"
          loading-bg-color="#8fd7f7"
          loading-src="scenes/citylights/img/loading.svg"
          logo="scenes/citylights/img/logo.svg"></citylights-scene>

      <codeboogie-scene route="codeboogie" icon="1f4dd"
          path$="scenes/codeboogie/codeboogie-scene_[[language]].html"
          header-color="#9a519f"
          loading-bg-color="#3f4ea1"
          feature-color="#f9ce1d"
          loading-src="scenes/codeboogie/img/loading.svg"
          hero-src="scenes/codeboogie/img/share.svg"
          logo="scenes/codeboogie/img/logo.svg"></codeboogie-scene>

      <codelab-scene route="codelab" icon="1f4dd"
          path$="scenes/codelab/codelab-scene_[[language]].html"
          header-color="#9a519f"
          loading-bg-color="#3f4ea1"
          feature-color="#f9ce1d"
          loading-src="scenes/codelab/img/loading.svg"
          logo="scenes/codelab/img/logo.svg"></codelab-scene>

      <commandcentre-scene route="commandcentre" icon="1f5fc"
          path$="scenes/commandcentre/commandcentre-scene_[[language]].html"
          header-color="#575769"
          loading-bg-color="rgb(129,208,0)"
          logo="scenes/commandcentre/img/logo.svg"></commandcentre-scene>

      <elfski-scene route="elfski" icon="1f3bf"
          path$="scenes/elfski/elfski-scene.html"
          loading-src="scenes/elfski/img/loading.svg"
          hero-src="scenes/elfski/img/gameover.svg"
          logo="scenes/commandcentre/img/logo.svg"></elfski-scene>

      <factory-scene route="factory" icon="1f3ed"
          path$="scenes/factory/factory-scene_[[language]].html"
          loading-bg-color="rgb(129,208,0)"
          logo="scenes/factory/img/logo.svg"></factory-scene>

      <glider-scene route="glider" icon="1f343"
          path$="scenes/glider/glider-scene_[[language]].html"
          header-color="#675ab9"
          loading-bg-color="#8d23a9"
          loading-src="scenes/glider/img/loading.svg"
          logo="scenes/glider/img/logo.svg"></glider-scene>

      <gumball-scene route="gumball" icon="1f36d"
          path$="scenes/gumball/gumball-scene_[[language]].html"
          header-color="#fdbe27"
          loading-bg-color="#8d23a9"
          loading-src="scenes/gumball/img/loading.svg"
          logo="scenes/gumball/img/logo.svg"></gumball-scene>

      <icecave-scene route="icecave" icon="2744"
          path$="scenes/icecave/icecave-scene_[[language]].html"></icecave-scene>

      <island-scene route="island" icon="1f334"
          path$="scenes/island/island-scene_[[language]].html"
          header-color="#1da1a1"></island-scene>

      <jamband-scene route="jamband" icon="1f3b6"
          path$="scenes/jamband/jamband-scene_[[language]].html"
          header-color="#1866be"
          loading-bg-color="#1866be"
          loading-src="scenes/jamband/img/loading.svg"
          hero-src="scenes/jamband/img/share.svg"
          logo="scenes/jamband/img/logo.svg"></jamband-scene>

      <jetpack-scene route="jetpack" icon="1f680"
          path$="scenes/jetpack/jetpack-scene_[[language]].html"
          header-color="#9a519f"
          loading-bg-color="#8fd7f7"
          loading-src="scenes/jetpack/img/loading.svg"
          logo="scenes/jetpack/img/logo.svg"></jetpack-scene>

      <latlong-scene route="latlong" icon="1f3af"
          path$="scenes/latlong/latlong-scene_[[language]].html"
          header-color="#76b1cc"
          loading-bg-color="#ffcc00"
          loading-src="scenes/latlong/img/loading.svg"
          logo="scenes/latlong/img/logo.svg"></latlong-scene>

      <newtracker-scene route="tracker" icon="1f30d"
          path$="scenes/newtracker/newtracker-scene_[[language]].html"
          header-color="#00cc81"
          allow-page-scrolling></newtracker-scene>

      <matching-scene route="matching" icon="1f6aa"
          path$="scenes/matching/matching-scene_[[language]].html"
          header-color="#76b1cc"
          loading-bg-color="#b27644"
          loading-src="scenes/matching/img/loading.svg"
          logo="scenes/matching/img/logo.svg"></matching-scene>

      <mercator-scene route="mercator" icon="1f30e"
          path$="scenes/mercator/mercator-scene_[[language]].html"
          loading-bg-color="#fbbf2c"
          loading-src="scenes/mercator/img/loading.svg"
          logo="scenes/mercator/img/logo.svg"></mercator-scene>

      <penguindash-scene route="penguindash" icon="1f680"
          path$="scenes/penguindash/penguindash-scene_[[language]].html"
          header-color="#9a519f"
          loading-bg-color="#8fd7f7"
          loading-src="scenes/penguindash/img/loading.svg"
          logo="scenes/penguindash/img/logo.svg"></penguindash-scene>

      <playground-scene route="playground" icon="1f3aa"
          path$="scenes/playground/playground-scene_[[language]].html"
          header-color="#575769"
          loading-bg-color="rgb(251, 191, 44)"
          logo="scenes/playground/img/logo.svg"></playground-scene>

      <postcard-scene route="postcard" icon="1f4ec"
          path$="scenes/postcard/postcard-scene_[[language]].html"
          header-color="rgb(244, 123, 32)"
          loading-bg-color="rgb(244, 123, 32)"
          loading-src="scenes/postcard/img/loading.gif"
          logo="scenes/postcard/img/logo.svg"></postcard-scene>

      <presentbounce-scene route="presentbounce" icon="1f381"
          path$="scenes/presentbounce/presentbounce-scene_[[language]].html"
          header-color="#e53935"
          loading-bg-color="#8fd7f7"
          loading-src="scenes/presentbounce/img/loading.svg"
          logo="scenes/presentbounce/img/logo.svg"></presentbounce-scene>

      <presentdrop-scene route="presentdrop" icon="1f381"
          path$="scenes/presentdrop/presentdrop-scene_[[language]].html"
          header-color="#b4b6b9"
          loading-bg-color="#8fd7f7"
          loading-src="scenes/presentdrop/img/loading.svg"
          logo="scenes/presentdrop/img/logo.svg"></presentdrop-scene>

      <racer-scene route="racer" icon="1f3c1"
          path$="scenes/racer/racer-scene_[[language]].html"
          loading-bg-color="#8fd7f7"
          loading-src="scenes/racer/img/loading.svg"
          logo="scenes/racer/img/logo.svg"></racer-scene>

      <rollercoaster-scene route="rollercoaster" icon="1f3a2"
          path$="scenes/rollercoaster/rollercoaster-scene.html"
          logo="scenes/rollercoaster/img/logo.svg"></rollercoaster-scene>

      <runner-scene route="runner" icon="1f3c7"
          path$="scenes/runner/runner-scene_[[language]].html"
          header-color="#575769"
          logo="scenes/runner/img/logo.svg"></runner-scene>

      <santascanvas-scene route="santascanvas" icon="1F3A8"
          path$="scenes/santascanvas/santascanvas-scene_[[language]].html"
          header-color="#00c6ed"
          loading-bg-color="#3fb8f1"
          loading-src="scenes/santascanvas/img/loading.svg"
          hero-src="scenes/santascanvas/img/share.svg"
          logo="scenes/santascanvas/img/icon.svg"></santascanvas-scene>

      <santasearch-scene route="santasearch" icon="1f50d"
          path$="scenes/santasearch/santasearch-scene_[[language]].html"
          header-color="#00904a"
          feature-color="#f9ce1d"
          loading-bg-color="#29B6F6"
          loading-src="scenes/santasearch/img/loading.svg"
          hero-src="scenes/santasearch/img/gameover.svg"
          logo="scenes/santasearch/img/logo.svg"></santasearch-scene>

      <santaselfie-scene route="santaselfie" icon="1f488"
          path$="scenes/santaselfie/santaselfie-scene_[[language]].html"
          header-color="#4172e8"
          loading-bg-color="#83D7F5"
          loading-src="scenes/santaselfie/img/loading.svg"
          hero-src="scenes/santaselfie/img/share.svg"
          logo="scenes/santaselfie/img/pole.svg"></santaselfie-scene>

      <seasonofgiving-scene route="seasonofgiving" icon="1f3ee"
          path$="scenes/seasonofgiving/seasonofgiving-scene_[[language]].html"
          header-color="#09904a"
          loading-src="scenes/seasonofgiving/img/loading.svg"
          logo="scenes/seasonofgiving/img/header-icon.svg"></seasonofgiving-scene>

      <smatch-scene route="smatch" icon="1f3e1"
          path$="scenes/smatch/smatch-scene_[[language]].html"
          header-color="#00c6ed"
          loading-bg-color="rgb(129,208,0)"
          logo="scenes/smatch/img/logo.svg"></smatch-scene>

      <snowball-scene route="snowball" icon="2603*"
          path$="scenes/snowball/snowball-scene_[[language]].html"
          loading-bg-color="#71a7db"
          loading-src="scenes/snowball/img/loading.svg"
          logo="scenes/snowball/img/logo.svg"></snowball-scene>

      <snowflake-scene route="snowflake" icon="2744*"
          path$="scenes/snowflake/snowflake-scene_[[language]].html"
          loading-bg-color="rgb(129,208,0)"
          logo="scenes/snowflake/img/logo.svg"></snowflake-scene>

      <speedsketch-scene route="speedsketch" icon="1f916"
          path$="scenes/speedsketch/speedsketch-scene_[[language]].html"
          header-color="#00C6ED"
          loading-bg-color="#009933"
          loading-src="scenes/speedsketch/img/splashscreen-image.svg"
          logo="scenes/speedsketch/img/icon.svg"></speedsketch-scene>

      <streetview-scene route="streetview" icon="1f3a5"
          path$="scenes/streetview/streetview-scene_[[language]].html"
          loading-bg-color="rgb(129,208,0)"
          logo="scenes/streetview/img/logo.svg"></streetview-scene>

      <traditions-scene route="traditions" icon="1f4cc"
          path$="scenes/traditions/traditions-scene_[[language]].html"
          header-color="#fdbe27"
          loading-bg-color="rgb(255,224,0)"
          loading-src="scenes/traditions/img/loading.gif"
          logo="scenes/traditions/img/traditions_icon.svg"></traditions-scene>

      <translations-scene route="translations" icon="1f4e2"
          path$="scenes/translations/translations-scene_[[language]].html"
          header-color="#558b2f"
          feature-color="#83ce00"
          loading-bg-color="#8fd7f7"
          loading-src="scenes/translations/img/loading.png"
          logo="scenes/translations/img/logo.svg"></translations-scene>

      <trivia-scene route="trivia" icon="1f914"
          path$="scenes/trivia/trivia-scene_[[language]].html"
          logo="scenes/traditions/img/traditions_icon.svg"></trivia-scene>

      <undersea-scene route="undersea" icon="1f30a"
          path$="scenes/undersea/undersea-scene_[[language]].html"
          header-color="#ba594e"></undersea-scene>

      <template is="dom-repeat" items="[[_computeVideoRoutes()]]">
        <video-scene route$="[[item]]" icon="1f4fd"
            header-color="#ea4882"
            feature-color="#f9ce1d"
            logo="scenes/videoscene/img/logo.svg"
            path="scenes/videoscene/video-scene.html"
            slot="santa-scene"></video-scene>
      </template>

      <windtunnel-scene route="windtunnel" icon="1f38f"
          path$="scenes/windtunnel/windtunnel-scene_[[language]].html"
          header-color="#575769"
          loading-bg-color="rgb(129,208,0)"
          logo="scenes/windtunnel/img/logo.svg"></windtunnel-scene>

      <wrapbattle-scene route="wrapbattle" icon="1f4fb"
          path$="scenes/wrapbattle/wrapbattle-scene_[[language]].html"
          header-color="#1866be"
          feature-color="#003799"
          loading-bg-color="#1866be"
          loading-src="scenes/wrapbattle/img/loading.svg"
          logo="scenes/wrapbattle/img/logo.svg"></wrapbattle-scene>
    </lazy-pages>

  </santa-chrome>

  <preload-bar progress="[[_progress]]" bootstrap="[[_bootstrap]]"></preload-bar>

</template>
<script>
(function() {

const META_THEME = document.head.querySelector('meta[name="theme-color"]')
    || document.createElement('meta');
const META_THEME_DEFAULT = META_THEME.content;
const TRACKER_ROUTE = 'tracker';
const ANALYTICS = new Analytics();

let messagePort;


const HOUSES_DICT = {};
window.HOUSES.forEach((house) => {
  HOUSES_DICT[house.module] = house;
});


function buildRandomHouses() {
  let count = 0;
  let weight = 0;
  const source = {};
  window.HOUSES.forEach((item) => {
    if (item.link) {
      return;
    }
    const value = item.edu ? 2 : 1;
    source[item.module] = value;
    weight += value;
    ++count;
  });

  const out = [];
  while (count) {
    let choice = (Math.random() * weight);
    let k;
    for (k in source) {
      choice -= source[k];
      if (choice <= 0) {
        break;
      }
    }
    weight -= source[k];
    --count;
    delete source[k];
    out.push(k);
  }

  return out;
}



Polymer({
  is: 'santa-app',
  hostAttributes: {'tabindex': '0'},

  properties: {

    /**
     * The size of the header, if any. Used by games to adjust their size.
     */
    headerSize: {
      type: Number,
      value: 0,
    },

    /**
     * Whether to use the History API for routing.
     */
    routing: {
      type: Boolean,
      reflectToAttribute: true,
      value: false,
    },

    /**
     * The house metadata, including unlock information.
     */
    houses: {
      type: Array,
      readOnly: true,
      notify: true,
      value: window.HOUSES,
    },

    _housesLocked: {
      type: Object,
      value: () => {},
    },

    /**
     * Whether sounds are muted by the user.
     */
    userMute: {
      type: Boolean,
      observer: '_userMuteChanged',
    },

    /**
     * Whether the game is paused by the user. Only effects games that can actually be paused!
     */
    userPause: {
      type: Boolean,
      value: false,
    },

    /**
     * Whether the page is currently in the background.
     */
    pageInBackground: {
      type: Boolean,
      readOnly: true,
    },

    /**
     * Whether the current game should be paused (if it can be paused), based on (userPause ||
     * pageInBackground).
     */
    pause: {
      type: Boolean,
      computed: '_computePause(userPause, pageInBackground)',
      observer: '_pauseChanged',
    },

    /**
     * The current language locale. This is not modifable after launch; reload the site.
     */
    language: {
      type: String,
      readOnly: true,
      value: () => document.documentElement.lang || 'en',
    },

    /**
     * The currently open scene.
     */
    selectedScene: {
      type: Element,
      observer: '_selectedSceneChanged',
      value: null,
    },

    /**
     * Current URL route.
     */
    route: {
      type: String,
      observer: '_routeChanged',
    },

    /**
     * The progress value bound from `lazy-pages`.
     */
    _progress: {
      type: Number,
    },

    /**
     * The bootstrap scene, bound from `lazy-pages`.
     */
    _bootstrap: {
      type: Boolean,
    },

    /** Whether the schedule is checked. If false, houses will remain unlocked. */
    scheduleChecked: {
      type: Boolean,
      value: true,
      observer: '_scheduleCheckedChanged',
    },

    /**
     * The mode of Santa Tracker. Possible values are blank, 'cast', 'portal',
     * or 'embed'.
     *
     * 'portal': Portal mode indicates that Santa Tracker is being run in a web
     * kiosk or similar device.
     *
     * 'cast': Cast mode indicates that Santa Tracker is being run on a casted
     * device.
     *
     * 'embed': embed mode indicates that a Santa Tracker scene is being called
     * from within one of the native Santa Tracker frontends (e.g. Android/iOS
     * app).
     */
    mode: {
      type: String,
      value: '',
    },

    /**
     * True when the countdown is complete, and the tracker is active. Bound from `santa-state`.
     */
    duringTracker: {
      type: Boolean,
      notify: true,
      observer: '_duringTrackerChanged',
    },

    /**
     * Current time as per the Santa API. Bound from `santa-state`. This is updated only every few
     * minutes.
     */
    currentTime: {
      type: Number,
    },

    /**
     * Whether a reload has been requested. Bound from `santa-state`.
     */
    requestedReload: {
      type: Boolean,
    },

    _randomHouses: {
      type: Array,
      value: buildRandomHouses(),
    },

    nextRandom: {
      type: String,
      computed: '_computeNextRandom(_housesLocked, _randomHouses, scheduleChecked, route)',
    },

  },

  observers: [
    '_updateLock(currentTime)',
  ],

  listeners: {
    'click': 'onClick',
    'beforeload': 'onBeforeLoad',
    'analytics-time-start': 'timeStart',
    'analytics-time-end': 'timeEnd',
    'analytics-track-game-start': 'trackGameStart',
    'analytics-track-game-quit': 'trackGameQuit',
    'analytics-track-game-over': 'trackGameOver',
    'nav': 'onNav',
    'random': 'onRandom',
    'game-restart': 'onRestartGame',
    'game-extra': 'onGameExtra',
    'game-resume': 'onResumeGame',
    'game-stop': 'onStopGame',
    'game-score': 'onScoreGame',
    'video-load': 'onVideoLoad',
    'video-play': 'onVideoPlay',
    'video-done': 'onVideoDone',
    'close-drawer': 'onCloseDrawer',
    'houses-changed': 'onHousesChanged',
  },

  created: function() {
    // silence the noisy things
    if (!window.DEV) {
      console.log = function() {};
    }

    // prepareHouses code: before anything else. This needs to happen here because otw
    // _currentTimeChanged can actually be invoked before ready: is called.
    // TODO(samthor): This could be moved outside `santa-app`, it doesn't use any state.

    const portalMode = getUrlParameter('mode') === 'web_portal';
    const ios = navigator.userAgent.match(/iPhone|iPod|iPad/i);

    for (let i = 0, house; house = window.HOUSES[i]; ++i) {
      house.disabled = false;
      switch (house.module) {
        case 'app':
          // Disable Google Play house on iOS devices
          house.disabled |= (ios || portalMode);
          break;
      }
    }
  },

  ready: function() {
    if (getUrlParameter('mode') === 'web_portal') {
      this.mode = 'portal';
    }

    // Don't load sounds in Cast mode.
    if (this.mode !== 'cast') {
      const staticUrl = this.resolveUrl('../../');
      const sc = new SoundController(staticUrl);
      this.addEventListener('sound-preload', (ev) => {
        // call SoundController, which returns a Promise, which we can add to the source.
        // nb. This breaks the sound-preload abstraction a bit, but works fine.
        const p = sc.loadSounds(ev);
        const source = this._sceneForEvent(ev);
        source && source.preloadPromise(p);
      });
      this.addEventListener('sound-ambient', sc.playAmbientSounds.bind(sc));
      this.addEventListener('sound-trigger', sc.playSound.bind(sc));
    }

    const handler = () => this._setPageInBackground(document.hidden || false);
    document.addEventListener('visibilitychange', handler);
    handler();
  },

  attached: function() {
    if (this.route !== undefined) {
      return;
    }

    let route = this.defaultRoute;
    if (window.location.hash) {
      // drop old query #foo?blah=1...
      const parts = window.location.hash.substr(1).split('?');
      route = parts[0] || route;
    }
    this.route = route;
  },

  detached: function() {
    throw new Error('santa-app was detached');
  },

  onClick: function(ev) {
    const link = ev.composedPath().filter((el) => el.localName === 'a' && el.href)[0];
    if (!link) { return; }

    // Ignore if a reload was requested. Allow the new page to load naturally!
    if (this.requestedReload) { return; }

    // Ignore hash links.
    if (link.getAttribute('href').substr(0, 1) === '#') { return; }

    // Ignore if some weird meta keys are hit, this is probably 'open in new tab'.
    if (ev.ctrlKey || ev.metaKey || ev.which > 1) { return; }

    // Check domain/origin/etc.
    const targetUrl = new URL(link.href);
    if (targetUrl.origin !== window.location.origin) { return; }

    // Check the URLs have the same dirname (e.g. "/foo/bar/" vs "/foo/bar/zing.html").
    const lastSlash = window.location.pathname.lastIndexOf('/');
    if (targetUrl.pathname.lastIndexOf('/') !== lastSlash) { return; }

    // Pull out either the flat "/", or "/foo.html" at this path.
    const m = /\/(?:(\w+)\.html|)$/.exec(targetUrl.pathname.substr(lastSlash));
    if (!m) { return; }

    // Set the route. Hooray! \o/
    const route = m[1] || this.defaultRoute;
    if (this.route === route) {
      this._defaultAction();
    }
    this.$.lazypages.load(route);
    ev.preventDefault();
  },

  get defaultRoute() {
    if (this.duringTracker) {
      return TRACKER_ROUTE;
    } else {
      return 'village';
    }
  },

  _sceneForEvent: function(ev) {
    const source = Polymer.dom(ev).path[0];
    if (source && source.preloadPromise) {
      return source;
    }
    return null;
  },

  onVideoLoad: function(ev) {
    const videoId = ev.detail;
    const scene = this._sceneForEvent(ev);

    const v = this.$.video;
    if (v.videoId !== videoId) {
      const p = v.cue(videoId);
      scene && scene.preloadPromise(p);
    }
  },

  onVideoPlay: function(ev) {
    this.$.video.play(ev.detail);
  },

  onVideoDone: function(ev) {
    this.$.video.reset();
    const ok = this.selectedScene && this.selectedScene.localName === 'video-scene';
    if (ok) {
      this.userPause = true;
    }
  },

  /**
   * Reset and update various bits of global state when a new scene is made visible.
   */
  _selectedSceneChanged: function(newValue, oldValue) {
    this.$.chrome.hasGameButtons = false;
    this.$.chrome.drawerOpen = false;
    this.userPause = false;

    this._updateStylingForScene(this.selectedScene);

    if (!this.selectedScene) {
      return;
    } else if (!this.selectedScene.is) {
      console.warn('got nonupgraded scene', this.selectedScene);
      return;
    }

    // nb. Effectively checking for SantaSceneGameButtonsBehavior.
    const hasPause = 'pause' in this.selectedScene;
    if (hasPause) {
      const scene = this.selectedScene;
      const now = +new Date();
      const retry = () => {
        if (!this.selectedScene.start()) {
          const since = (+new Date) - now;
          if (since > 5000) {
            throw new Error('could not start after 5s');
          }
          window.requestAnimationFrame(retry);
        }
      };
      retry();
    }
    this.fire('embed', {
      type: 'onready',
      data: {hasPauseScreen: hasPause},
    });  // notify embed scene is ready to show
  },

  _updateStylingForScene: function(scene) {
    const scrolling = !scene || scene.hasAttribute('allow-page-scrolling');

    // Allow scrolling body if scene requests it. Update `santa-chrome` to match.
    if (scrolling) {
      document.body.classList.remove('scrollock');
      this.$.chrome.classList.remove('fixed');
    } else {
      document.body.classList.add('scrollock');
      this.$.chrome.classList.add('fixed');
    }
    scene = scene || document.createElement('empty-scene');

    // Update custom colors and themes.
    const headerColor = scene.getAttribute('header-color');
    this.updateStyles({
      '--santa-header-color': headerColor,
      '--santa-feature-color': scene.getAttribute('feature-color'),
    });
    META_THEME.content = headerColor || META_THEME_DEFAULT;

    // Show the badge if not in allow-page-scrolling mode.
    if (this.$.badge.reset) {
      this.$.badge.reset();
    }
    this.$.badge.logoUrl = scene.getAttribute('logo');

    // Reset the overlay.
    if (this.$.overlay.reset) {
      this.$.overlay.reset();
    }
    this.$.overlay.hero = scene.getAttribute('hero-src');
    if ('pause' in scene) {
      this.$.overlay.hasPause = true;
      this.$.chrome.hasGameButtons = true;
    }

    // Optionally update the document title (with emoji/scene name).
    if (this.routing) {
      const raw = scene.getAttribute('icon');
      let icon = '';
      if (raw && String.fromCodePoint) {  // no emoji on IE11
        icon = String.fromCodePoint(parseInt(raw, 16));

        if (raw.endsWith('*')) {
          // add VS16/'force emoji' char
          icon += String.fromCodePoint(0xfe0f);
        }
      }
      document.title = icon + this.$.strings.s('meta_title');
    }
  },

  /**
   * Something is trying to load a scene. Try to work out whether it's open, and call
   * .preventDefault() if it's locked.
   */
  onBeforeLoad: function(ev) {
    const route = ev.detail;

    const item = HOUSES_DICT[route];
    if (item && item.edu) {
      return;  // edu is always available to load
    }

    if (this.sceneIsOpen(route) === false) {
      if (!window.DEV) {
        window.ga('send', 'event', 'Routing', 'locked', '/' + route);
        return ev.preventDefault();
      }
      console.debug('prod would lock', route);
    }
  },

  _routeChanged: function() {
    window.ga('set', 'page', '/' + (typeof this.route === 'string' ? this.route : ''));
    window.ga('send', 'pageview');
  },

  onNav: function(ev) {
    const route = ev.detaul || this.defaultRoute;
    if (this.route === route) {
      this._defaultAction();
    }
    this.$.lazypages.load(route);
  },

  _computeNextRandomForHint: function(nextRandom, route) {
    if (route === 'village' || route === 'tracker' || !route || route === nextRandom) {
      return null;
    }
    return nextRandom;
  },

  _computeNextRandom: function(housesLocked, randomHouses, scheduleChecked, route) {
    if (!housesLocked || !randomHouses) {
      return null;
    }

    let i;
    for (i = 0; i < randomHouses.length; ++i) {
      const check = randomHouses[i];
      if (route === check) {
        continue;
      }

      // this does NOT allow edu games, only serves open scenes
      if (!scheduleChecked || !housesLocked[check]) {
        break;
      }
    }

    const out = randomHouses[i] || null;
    if (out === null) {
      return out;
    }

    // reorder including self if found, but only if before new choice
    const index = randomHouses.indexOf(route);
    if (index !== -1 && index < i) {
      const done = this._randomHouses.splice(0, index + 1);
      this._randomHouses.push.apply(this._randomHouses, done);
      this._randomHouses = this._randomHouses.slice();  // force choice of nextRandom
    }

    return out;
},

  onRandom: function(ev) {
    const choice = this.nextRandom;
    this.$.lazypages.load(choice || this.defaultRoute);
  },

  /**
   * Handler for 'game-restart' event. Resests overlay state, and if the game supports pausing,
   * shows those buttons and starts the scene.
   */
  onRestartGame: function() {
    this.userPause = false;
    const scene = this.selectedScene;
    if (scene && scene.start) {
      scene.start();
      this.fire('embed', 'onstart');
    }
  },

  /** Handler for 'game-resume' event. Just unpauses. */
  onResumeGame: function() {
    this.userPause = false;
  },

  /** Handler for 'game-stop' event. Fired by the gameover shared JS component. */
  onStopGame: function(event, detail) {
    const o = this.$.overlay;
    detail = detail || {};
    o.score = 'score' in detail ? detail.score : null;  // allow zero
    o.shareUrl = detail.url || null;

    this.userPause = true;

    if (detail.url || detail.image) {
      this.fire('embed', {type: 'onshare', data: {
        url: detail.url || null,
        image: detail.image || null,
      }});
    } else {
      this.fire('embed', {type: 'ongameover', data: {
        score: o.score,
      }});
    }
  },

  onScoreGame: function(event, detail) {
    // TODO(samthor): This is technically racey. We can get scores for previous games.

    this.$.badge.score = detail.score !== undefined ? detail.score : null;
    this.$.badge.level = detail.level || null;
    this.$.badge.levels = detail.levels || detail.maxLevels || null;
    this.$.badge.time = detail.time || null;

    this.fire('embed', {type: 'onscore', data: {
      score: detail.score || 0,
      level: detail.level || 0,
      maxLevel: detail.levels || detail.maxLevels || 0,
      time: detail.time || 0,
    }});
  },

  _computePause: function(userPause, pageInBackground) {
    return userPause || pageInBackground;
  },

  _pauseChanged: function(pause) {
    const scene = this.selectedScene;
    if (scene && 'pause' in scene) {  // nb. does it implement SantaSceneGameButtonsBehavior
      scene.pause = pause;
    }
    if (pause) {
      this.fire('embed', 'onpause');
    } else {
      this.fire('embed', 'onresume');
      this.selectedScene && this.selectedScene.focus();
    }
  },

  _userMuteChanged: function() {
    // nb. dedup this as sound-ambient is bound inside ready:, and changes <frame confuse Klang
    this.debounce('_userMute', function() {
      this.fire('sound-ambient', this.userMute ? 'global_sound_off' : 'global_sound_on');
    }, 20);
  },

  timeStart: function(e, detail) {
    ANALYTICS.timeStart(
        detail.category, detail.variable, detail.time);
  },

  timeEnd: function(e, detail) {
    ANALYTICS.timeEnd(
        detail.category, detail.variable, detail.time, detail.label, detail.maxTime);
  },

  trackGameStart: function(e, detail) {
    ANALYTICS.trackGameStart(detail.gameId || detail.gameid);
  },

  trackGameQuit: function(e, detail) {
    ANALYTICS.trackGameQuit(detail.gameId || detail.gameid,
        detail.level, detail.timePlayed);
  },

  trackGameOver: function(e, detail) {
    ANALYTICS.trackGameOver(
        detail.gameId || detail.gameid, detail.score, detail.level,
        detail.timePlayed);
  },

  unlockAllHouses: function() {
    window.ga('send', 'event', 'Routing', 'unlockAllHouses');
    this.scheduleChecked = false;
  },

  /**
   * In 2018+, all houses are unlocked all the time.
   *
   * @param {string} sceneName to check
   * @return {boolean=} true if open, false if not, or undefined if unknown
   */
  sceneIsOpen: function(sceneName) {
    if (!this.scheduleChecked) {
      return true;
    }
    return !this._housesLocked[sceneName];
  },

  /**
   * Unlocks the correct houses based on the day (index).
   * @private
   */
  _updateLock: function(currentTime) {
    const localNow = new Date();
    const now = this.currentTime || (+localNow);

    // launchDate is in local time, but we want it in "NZ time" (GMT+13)
    const targetTimeZone = -13;
    const targetOffset = (targetTimeZone * 60);
    const offsetDelta = targetOffset - localNow.getTimezoneOffset();  // always 'local' tz offset

    // update behavior, replace _housesLocked later if anything changed
    const previousLocked = this._housesLocked || {};
    let updateLocked = null;
    const update = (sceneName, locked) => {
      if (Boolean(previousLocked[sceneName]) !== locked) {
        if (!updateLocked) {
          updateLocked = {};
        }
        if (locked) {
          updateLocked[sceneName] = true;
        }
      }
    };

    // tracker is locked not during tracker
    update(TRACKER_ROUTE, !this.duringTracker);

    // check all houses
    this.houses.map((item) => {
      if (!item.launchDate) {
        return false;  // no launch date, locked
      }

      // locked if before check time
      const checker = new Date(item.launchDate);
      checker.setMinutes(checker.getMinutes() + offsetDelta);
      return now < +checker;
    }).forEach((locked, i) => {
      update(this.houses[i].module, locked);
    });

    if (updateLocked) {
      this._housesLocked = Object.freeze(updateLocked);
      this.fire('houses-changed');
    }
  },

  _onKeysPressed: function(e, detail) {
    switch (detail.key) {
      case 'esc':
        if (this._defaultAction()) {
          this.$.lazypages.load(this.defaultRoute);
        }
        break;
    }
  },

  /**
   * Perform the 'default action': when the title is clicked, esc is hit etc.
   *
   * @return {boolean} whether no action was performed
   */
  _defaultAction: function() {
    let action = false;

    if (this.$.chrome.drawerOpen) {
      this.$.chrome.drawerOpen = false;
      action = true;
    }
    if (window.scrollY > 0) {
      window.scrollTo(0, 0);
      action = true;
    }

    return !action;
  },

  _scheduleCheckedChanged: function() {
    this.fire('houses-changed');
  },

  _duringTrackerChanged: function() {
    // If the tracker was open, it's now locked: send the user back to the Village.
    if (this.duringTracker === false && this.route === TRACKER_ROUTE) {
      this.$.lazypages.load(this.defaultRoute);
    }
  },

  onCloseDrawer: function(event) {
    this.$.chrome.drawerOpen = false;
  },

  onHousesChanged: function() {
    this.nextRandom = this._nextRandom;
    this.$.lazypages.revalidate();
  },

  /**
   * Returns the (static) color for the given route. Returns the blank string if there is no color.
   */
  colorForRoute: function(route) {
    const draft = this.$.lazypages.getDraft(route);
    return draft && draft.getAttribute('header-color') || '';
  },

  omitSantaChrome: function(mode) {
    return mode === 'cast' || mode === 'embed';
  },

  _computeOverlayHidden: function(userPause, mode) {
    if (mode === 'cast' || mode === 'embed') {
      return true;
    }
    return !userPause;
  },

  /**
   * Converts the map of routes -> YouTube IDs to an array of routes.
   */
  _computeVideoRoutes: function() {
    return Object.keys(VIDEOS);
  },

});

})();
</script>
</dom-module>
