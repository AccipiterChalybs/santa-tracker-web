<!--
Copyright 2015 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../components/polymer/polymer.html">

<!--
Wraps the SantaService object for Santa Tracker. This is a singleton that provides information
about Santa's current status: e.g., pre- or post- flight, time before takeoff etc.
-->
<dom-module id="santa-state">
<script>
(function() {

const YEAR = 2017;
const FLIGHT_HOURS = 25;
const CALENDAR_OPEN = +Date.UTC(YEAR, 10, 30, 10, 0, 0);  // 30st Nov at 10:00 UTC
const COUNTDOWN_END = +Date.UTC(YEAR, 11, 24, 10, 0, 0);  // 24th Dec at 10:00 UTC
const FLIGHT_FINISHED = COUNTDOWN_END + (FLIGHT_HOURS * 60 * 60 * 1000);

const VERSION = document.body.getAttribute('data-version');
const LANGUAGE = document.documentElement.lang || 'en';
const API_CLIENT = (function() {
  let apiClient = getUrlParameter('api_client');
  if (!apiClient || !apiClient.match(/^[a-zA-Z_]*$/) || apiClient === 'web_portal') {
    apiClient = 'web';
  }
  return apiClient;
}());

const santaService = new SantaService(API_CLIENT, LANGUAGE, VERSION);
const instances = new Set();

santaService.addListener('kill', function() {
  window.ga('send', 'event', 'API', 'killed');
  window.setTimeout(() => {
    window.location = 'error.html';
  }, 1000);
});

let requestedReload = false;
santaService.addListener('reload', function() {
  if (requestedReload) {
    return;
  }
  requestedReload = true;
  instances.forEach((instance) => instance._setRequestedReload(true));

  if (window.sw) {
    window.ga('send', 'event', 'API', 'sw-update', VERSION);
    window.sw.then((sw) => sw.update());  // request SW update, void return
  }

  if (!VERSION || window.DEV) {
    console.warn('dev ignoring reload request', VERSION);
    return;
  }
  console.info('version reload requested', VERSION);
  window.ga('send', 'event', 'API', 'reload', VERSION);

  // At 10m +/- 5m, try to reload if the page is hidden. After that, reload when the page is
  // made hidden, or force a reload after the same duration again.
  const duration = (Math.random() + 0.5) * (10 * 60 * 1000);
  window.setTimeout(function reloader(force) {
    if (force || document.hidden) {
      window.location.reload();
    } else {
      // since !document.hidden, the next call to reloader will reload
      document.addEventListener('visibilitychange', reloader);
      window.setTimeout(reloader.bind(null, true), duration);
    }
  }, duration);
});

let currentTime = Date.now();  // TODO(samthor): could be undefined to start with?
let notifyTimeout = window.setTimeout(notifyCurrentTime, 2500);  // trigger after 2.5s
function notifyCurrentTime() {
  window.clearTimeout(notifyTimeout);

  currentTime = santaService.now();
  instances.forEach((instance) => instance._setCurrentTime(currentTime));

  // Just in case the user is offline or santaService doesn't call back, inform all clients on the
  // hour, every hour. This lets houses unlock and states transition.
  const interval = (60 * 60 * 1000);
  const notifyAt = Math.ceil(currentTime / interval) * interval;
  notifyTimeout = window.setTimeout(notifyCurrentTime, notifyAt - currentTime);
}
santaService.addListener('sync', notifyCurrentTime);

let offline = false;
function notifyOffline() {
  offline = santaService.isOffline();
  instances.forEach((instance) => instance._setOffline(offline));
}
santaService.addListener('offline', notifyOffline);
santaService.addListener('online', notifyOffline);

window.santaService = santaService;

Polymer({
  is: 'santa-state',

  properties: {

    /**
     * Whether the user is offline.
     */
    offline: {
      type: Boolean,
      readOnly: true,
      notify: true,
      value: () => offline,
    },

    /**
     * Whether a reload of the site has been requested.
     */
    requestedReload: {
      type: Boolean,
      readOnly: true,
      notify: true,
      value: () => requestedReload,
    },

    /**
     * The language of the site.
     */
    language: {
      type: String,
      readOnly: true,
      notify: true,
      value: LANGUAGE,
    },

    /**
     * The current time in ms. This only changes every few minutes, not every second.
     */
    currentTime: {
      type: Number,
      readOnly: true,
      notify: true,
      value: () => currentTime,
    },

    /**
     * The remaining time in ms. This only changes every few minutes, not every second.
     */
    remainingTime: {
      type: Number,
      computed: '_computeRemainingTime(currentTime)',
      notify: true,
    },

    /**
     * Whether it is December and the calendar is open.
     */
    holidaySeason: {
      type: Boolean,
      computed: '_computeHolidaySeason(currentTime)',
      notify: true,
    },

    /**
     * Whether or not the countdown is complete (including after Santa's flight).
     */
    countdownFinished: {
      type: Boolean,
      computed: '_computeCountdownFinished(remainingTime)',
      notify: true,
    },

    /**
     * If we're during the window that the Tracker is open.
     */
    duringTracker: {
      type: Boolean,
      computed: '_computeDuringTracker(countdownFinished, postFlight)',
      notify: true,
    },

    /**
     * Whether or not it is after Santa has finished his big flight.
     */
    postFlight: {
      type: Boolean,
      computed: '_computePostFlight(currentTime)',
      notify: true,
    },

  },

  // nb. All time compute methods run O(n) times every few minutes.

  _computeHolidaySeason: function(currentTime) {
    return currentTime >= CALENDAR_OPEN && currentTime < FLIGHT_FINISHED;
  },
  _computeRemainingTime: function(currentTime) {
    return Math.max(0, COUNTDOWN_END - currentTime);
  },
  _computeCountdownFinished: function(remainingTime) {
    return remainingTime <= 0;
  },
  _computeDuringTracker: function(countdownFinished, postFlight) {
    return countdownFinished && !postFlight;
  },
  _computePostFlight: function(currentTime) {
    return currentTime >= FLIGHT_FINISHED;
  },

  created: function() {
    instances.add(this);  // aggressively add to instances, to catch all updates
  },

  attached: function() {
    instances.add(this);
  },

  detached: function() {
    instances.delete(this);
  },

});

}());

</script>
</dom-module>
