<!--
Copyright 2017 Google Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at

      http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed
under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied. See the License for the
specific language governing permissions and limitations under the License.
-->
<link rel="import" href="../components/polymer/polymer.html">

<!--
Provides network access for Santa Tracker.
-->
<dom-module id="santa-socket">
<script>
(function() {

Polymer({
  is: 'santa-socket',

  properties: {

    /**
     * The endpoint to connect to.
     */
    endpoint: {
      type: String,
      value: 'ws://localhost:8080',
    },

    /**
     * Null/empty for no mode, 'host' or 'client'.
     */
    mode: {
      type: String,
      value: null,
    },

    /**
     * Whether currently connected.
     */
    connected: {
      type: Boolean,
      value: false,
      readOnly: true,
      notify: true,
    },

    /**
     * The internal WebSocket, if connected.
     */
    _socket: {
      type: Object,
      value: null,
    },

    /**
     * The target hostId for clients.
     */
    clientHostId: {
      value: null,
      type: Number,
    },

    /**
     * The current unique ID, if any. This is set for clients and servers.
     */
    id: {
      value: null,
      type: Number,
      readOnly: true,
      notify: true,
    },

    /**
     * Current active clients. This is a frozen array. Host-only.
     */
    clients: {
      value: null,
      type: Array,
      readOnly: true,
      notify: true,
    },

    /**
     * The Promise determining whether the socket is ready. May be null.
     */
    _readyPromise: {
      type: Object,
      value: null,
    },

  },

  observers: [
    '_maybeUpdateSocket(endpoint, mode, clientHostId)',
  ],

  _reset: function() {
    this._setConnected(false);
    this._socket && this._socket.close();
    this._socket = null;
    this._setId(null);
    this._setClients(null);
    this._readyPromise = null;
  },

  _maybeUpdateSocket: function(endpoint, mode, clientHostId) {
    this._reset();
    if (this.mode !== 'host' && this.mode !== 'client') {
      return;  // nothing else to do
    }

    var ws = new WebSocket(this.endpoint);
    var clients = new Set();
    this._socket = ws;
    this._setClients(Object.freeze([]));

    // wrap methods so they only operate if we're still the prevailing websocket
    var safe = function(cb) {
      return function() {
        if (ws !== this._socket) {
          return;  // ignore completely
        }
        return cb.apply(this, arguments);
      }.bind(this);
    }.bind(this);

    var resolved = false;
    this._readyPromise = new Promise(function(resolve, reject) {
      ws.addEventListener('message', safe(function(message) {
        const data = JSON.parse(message.data);

        switch (data.action) {
        case 'host':
          this._setId(data.id);
          console.info('got hostId', data.id);
          resolve(data.id);
          resolved = true;
          break;

        case 'client':
          this._setId(data.id);
          console.info('got clientId', data.id);
          resolve(data.id);
          resolved = true;
          break;

        case 'join':
          data.id && clients.add(data.id);
          this._setClients(Array.from(clients));
          break;

        case 'part':
          clients.delete(data.id);
          this._setClients(Array.from(clients));
          break;

        case 'data':
          var detail = {
            mode: this.mode,
            data: data.data,  // payload only
          };
          if ('id' in data) {
            detail.id = data.id;  // append if if client
          }
          this.fire('data', detail);
          break;

        default:
          console.warn('unknown action', data.action);
        }
      }));

      ws.addEventListener('error', safe(function() {
        this.fire('error');
        resolved || reject();

        if (this._socket === ws) {
          // don't change connected if owner changed
          this._setConnected(false);
        }
      }));

    }.bind(this));

    this._readyPromise.then(safe(function() {
      this._setConnected(true);
    }));

    // send kickoff message
    ws.addEventListener('open', safe(function() {
      var payload = {create: true};
      if (this.mode === 'client') {
        payload = {join: +this.clientHostId || 0};
      }
      ws.send(JSON.stringify(payload));
    }));
  },

  /**
   * @param {*} data to send
   * @return {!Promise<void>} when send done
   */
  send(data) {
    if (!this._readyPromise) {
      throw new Error('no socket to send data');
    }
    return this._readyPromise.then(() => {
      // TODO: can we make this resolve when send is actually done
      this.conn_.send(JSON.stringify(data));
    });
  },

});

}());
</script>
</dom-module>